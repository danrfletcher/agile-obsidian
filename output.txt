./src/features/agile-dashboard-view/app/controller.ts
import { Notice, type App, type ItemView } from "obsidian";
import type { TaskIndexService } from "@features/task-index";
import type { SettingsService } from "@settings";
import type { OrgStructurePort } from "@features/org-structure";
import { renderControlsBar } from "../ui/components/controls-bar";
import { attachDashboardAssignmentHandler } from "../ui/handlers/assignment-handler";
import { attachDashboardTemplatingHandler } from "../ui/handlers/templating-handler";
import { wireDashboardEvents } from "../ui/handlers/event-wiring";
import { TeamSelection } from "../domain/team-selection";
import type { DashboardState } from "../domain/view-state";
import { captureScroll, restoreScroll } from "../ui/utils/scroll";
import {
	renderTeamsPopupContent,
	TeamsPopupContext,
} from "../ui/views/teams-popup";
import { renderProjectView } from "../ui/views/project-view";
import { refreshForFile } from "./refresh-service";

type RegisterFn = (fn: () => void) => void;
type RegisterEventFn = (evt: any) => void;
type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

export interface DashboardControllerDeps {
	app: App;
	view: ItemView;
	taskIndexService: TaskIndexService;
	settingsService: SettingsService;
	orgStructurePort?: OrgStructurePort;
	manifestVersion: string;
	storageKey: string;

	register: RegisterFn;
	registerEvent: RegisterEventFn;
	registerDomEvent: RegisterDomEvent;
}

export class DashboardController {
	private state: DashboardState;
	private readonly teamSelection: TeamSelection;
	private teamsPopupEl: HTMLDivElement | null = null;
	private outsideClickHandler: ((ev: MouseEvent) => void) | null = null;
	private suppressedFiles = new Set<string>();

	constructor(private readonly deps: DashboardControllerDeps) {
		const initialAlias =
			deps.settingsService.getRaw().currentUserAlias || null;
		this.teamSelection = new TeamSelection(
			deps.settingsService,
			deps.orgStructurePort,
			deps.storageKey
		);
		this.state = {
			selectedView: "projects",
			activeOnly: true,
			selectedAlias: initialAlias,
		};
	}

	mount() {
		const container = this.getViewContainer();
		container.empty();

		// Controls
		renderControlsBar({
			container,
			version: this.deps.manifestVersion,
			settingsService: this.deps.settingsService,
			initialView: this.state.selectedView,
			initialActiveOnly: this.state.activeOnly,
			initialAlias: this.state.selectedAlias,
			onViewChange: (v) => {
				this.state.selectedView = v;
				this.updateView();
			},
			onActiveToggleChange: (active) => {
				this.state.activeOnly = active;
				this.updateView();
			},
			onMemberChange: (alias) => {
				this.state.selectedAlias = alias;
				this.teamSelection.restrictSelectedTeamsToUserMembership(
					this.state.selectedAlias
				);
				this.updateView();
				if (this.teamsPopupEl) this.renderTeamsPopup();
			},
			onSelectTeamsClick: (anchor) => this.toggleTeamsPopup(anchor),
			onRebuildIndexClick: async () => {
				// Show notice when starting rebuild, then a follow-up notice on completion or failure.
				new Notice("Rebuilding task index…", 1500);
				try {
					await this.deps.taskIndexService.buildAll();
					new Notice("Task index rebuilt.", 2000);
				} catch (e) {
					console.error("[agile-dashboard] Rebuild index failed", e);
					new Notice(
						"Failed to rebuild task index. See console for details.",
						4000
					);
				}
				await this.updateView();
			},
		});

		// Handlers (assignment + templating)
		attachDashboardAssignmentHandler({
			app: this.deps.app,
			orgStructurePort: this.deps.orgStructurePort,
			viewContainer: container,
			registerDomEvent: this.deps.registerDomEvent,
		});

		attachDashboardTemplatingHandler({
			app: this.deps.app,
			viewContainer: container,
			registerDomEvent: this.deps.registerDomEvent,
			refreshForFile: async (filePath?: string | null) => {
				await refreshForFile(
					this.deps.app,
					this.deps.taskIndexService,
					filePath
				);
				await this.updateView();
			},
		});

		// Initial render
		void this.updateView();

		// Event wiring (event bus + vault)
		wireDashboardEvents({
			app: this.deps.app,
			taskIndexService: this.deps.taskIndexService,
			viewRoot: container,
			getSelectedAlias: () => this.state.selectedAlias,
			updateView: () => this.updateView(),
			suppressedFiles: this.suppressedFiles,
			register: this.deps.register,
			registerEvent: this.deps.registerEvent,
		});
	}

	unmount() {
		this.closeTeamsPopup();
		if (this.outsideClickHandler) {
			try {
				window.removeEventListener("click", this.outsideClickHandler, {
					capture: true,
				} as any);
			} catch {}
			this.outsideClickHandler = null;
		}
	}

	// Rendering
	private getViewContainer(): HTMLElement {
		return (this.deps.view as any).containerEl.children[1] as HTMLElement;
	}

	private getOrCreateContentContainer(parent: HTMLElement): HTMLElement {
		const existing = parent.querySelector(
			".content-container"
		) as HTMLElement | null;
		return existing ?? parent.createEl("div", { cls: "content-container" });
	}

	async updateView() {
		const parent = this.getViewContainer();
		const scroll = captureScroll(parent);

		const content = this.getOrCreateContentContainer(parent);
		content.empty();

		if (this.state.selectedView === "projects") {
			await renderProjectView({
				app: this.deps.app,
				container: content,
				taskIndexService: this.deps.taskIndexService,
				settingsService: this.deps.settingsService,
				teamSelection: this.teamSelection,
				statusActive: this.state.activeOnly,
				selectedAlias: this.state.selectedAlias,
				registerDomEvent: this.deps.registerDomEvent,
			});
		} else {
			content.createEl("h2", { text: "✅ Completed (Coming Soon)" });
		}

		restoreScroll(parent, scroll);
	}

	// Teams popup
	private toggleTeamsPopup(anchor: HTMLElement) {
		if (this.teamsPopupEl) {
			this.closeTeamsPopup();
			return;
		}
		this.openTeamsPopup(anchor);
	}

	private openTeamsPopup(anchor: HTMLElement) {
		this.closeTeamsPopup();
		const popup = document.createElement("div");
		this.teamsPopupEl = popup;
		popup.classList.add("agile-teams-popup");
		popup.style.position = "absolute";
		popup.style.right = "0";
		popup.style.top = "calc(100% + 8px)";
		popup.style.zIndex = "9999";
		popup.style.minWidth = "320px";
		popup.style.maxWidth = "520px";
		popup.style.maxHeight = "60vh";
		popup.style.overflow = "auto";
		popup.style.padding = "10px";
		popup.style.border = "1px solid var(--background-modifier-border)";
		popup.style.borderRadius = "8px";
		popup.style.background = "var(--background-primary)";
		popup.style.boxShadow = "0 6px 24px rgba(0,0,0,0.2)";
		anchor.parentElement?.appendChild(popup);
		this.renderTeamsPopup();
	}

	private closeTeamsPopup() {
		if (this.teamsPopupEl) {
			try {
				this.teamsPopupEl.remove();
			} catch {}
			this.teamsPopupEl = null;
		}
	}

	private renderTeamsPopup() {
		if (!this.teamsPopupEl) return;

		const ctx: TeamsPopupContext = {
			root: this.teamsPopupEl,
			orgStructurePort: this.deps.orgStructurePort,
			selectedTeamSlugs: this.teamSelection.getSelectedTeamSlugs(),
			implicitAllSelected: this.teamSelection.getImplicitAllSelected(),
			setImplicitAllSelected: (val: boolean) => {
				this.teamSelection.setImplicitAllSelected(val);
			},
			addSelectedSlugs: (slugs: string[]) => {
				this.teamSelection.addSelectedSlugs(slugs);
			},
			removeSelectedSlugs: (slugs: string[]) => {
				this.teamSelection.removeSelectedSlugs(slugs);
			},
			onSelectionChanged: () => {
				this.renderTeamsPopup();
				this.updateView();
			},
			getAllowedTeamSlugsForSelectedUser: () =>
				this.teamSelection.getAllowedTeamSlugsForSelectedUser(
					this.state.selectedAlias
				),
		};

		renderTeamsPopupContent(ctx);
	}
}

./src/features/agile-dashboard-view/app/event-bus.ts
/**
 * Typed EventBus for Agile Dashboard custom events.
 * Wraps window.dispatchEvent/addEventListener with strong payload types and simple lifecycle.
 *
 * Purpose:
 * - Decouple UI modules and the view via well-defined events.
 * - Make event usage type-safe and easy to test (by overriding the target).
 */

export type AgileEvents = {
	"agile:prepare-optimistic-file-change": { filePath: string };
	"agile:task-status-updated": {
		uid?: string;
		filePath?: string;
		newStatus?: string;
	};
	"agile:task-snoozed": { uid?: string; filePath?: string; date?: string };
	"agile:task-updated": { filePath?: string };

	"agile:assignee-changed": {
		filePath: string;
		parentLine0: number;
		beforeLines?: string[] | null;
		newAssigneeSlug: string | null;
		oldAssigneeSlug?: string | null;
		parentUid?: string | null;
	};
	"agile:assignment-changed": {
		uid: string;
		filePath: string;
		newAlias: string;
	};
	"agile:request-assign-propagate": { uid: string; newAlias: string };
};

type EventName = keyof AgileEvents;
type Handler<N extends EventName> = (payload: AgileEvents[N]) => void;

export class EventBus {
	constructor(
		private readonly target:
			| Window
			| Pick<
					Window,
					"addEventListener" | "removeEventListener" | "dispatchEvent"
			  >
			| null = typeof window !== "undefined" ? window : null
	) {}

	on<N extends EventName>(name: N, handler: Handler<N>): () => void {
		if (!this.target) return () => {};
		const listener = (ev: Event) => {
			const ce = ev as CustomEvent<AgileEvents[N]>;
			handler(ce.detail ?? ({} as AgileEvents[N]));
		};
		this.target.addEventListener(name as string, listener as EventListener);
		return () =>
			this.target?.removeEventListener?.(
				name as string,
				listener as EventListener
			);
	}

	once<N extends EventName>(name: N, handler: Handler<N>): () => void {
		if (!this.target) return () => {};
		const listener = (ev: Event) => {
			const ce = ev as CustomEvent<AgileEvents[N]>;
			handler(ce.detail ?? ({} as AgileEvents[N]));
			this.target?.removeEventListener?.(
				name as string,
				listener as EventListener
			);
		};
		this.target.addEventListener(name as string, listener as EventListener);
		return () =>
			this.target?.removeEventListener?.(
				name as string,
				listener as EventListener
			);
	}

	off<N extends EventName>(name: N, handler: Handler<N>): void {
		// Note: Off only works if the same reference used in `on` is provided here.
		if (!this.target) return;
		this.target.removeEventListener(
			name as string,
			handler as unknown as EventListener
		);
	}

	dispatch<N extends EventName>(name: N, payload: AgileEvents[N]): void;

	dispatch(name: string, payload?: any): void;
	dispatch(name: string, payload?: any): void {
		if (!this.target) return;
		this.target.dispatchEvent(
			new CustomEvent(name as string, { detail: payload })
		);
	}
}

// Singleton for convenience (no-SSR safe)
export const eventBus = new EventBus(
	typeof window !== "undefined" ? window : null
);

./src/features/agile-dashboard-view/app/refresh-service.ts
import { TFile, type App } from "obsidian";
import type { TaskItem, TaskIndexService } from "@features/task-index";
import { renderTaskTree } from "../ui/components/task-renderer";
import { normalizeSection } from "../ui/components/ui-policy";

export async function refreshForFile(
	app: App,
	taskIndexService: TaskIndexService,
	filePath?: string | null
) {
	try {
		if (filePath) {
			const af = app.vault.getAbstractFileByPath(filePath);
			if (af instanceof TFile) {
				await taskIndexService.updateFile(af);
			}
		}
	} catch {
		/* ignore */
	}
}

export async function refreshTaskTreeByUid(
	app: App,
	taskIndexService: TaskIndexService,
	viewRoot: HTMLElement,
	uid: string,
	selectedAlias: string | null
) {
	const contentRoot = viewRoot.querySelector(
		".content-container"
	) as HTMLElement | null;
	if (!contentRoot) return;

	const allLis = Array.from(
		contentRoot.querySelectorAll("li[data-task-uid]")
	) as HTMLElement[];
	const li = allLis.find(
		(el) => (el.getAttribute("data-task-uid") || "") === uid
	);
	if (!li) return;

	// Prefer most-local section type: LI -> nearest UL -> enclosing section root -> fallback
	const rawSectionType =
		li.getAttribute("data-section") ||
		(
			li.closest(
				"ul.agile-dashboard.contains-task-list"
			) as HTMLElement | null
		)?.getAttribute("data-section") ||
		(li.closest("[data-section-root]") as HTMLElement | null)?.getAttribute(
			"data-section-root"
		) ||
		"tasks";

	const sectionType = normalizeSection(rawSectionType);

	const task = (taskIndexService.getById?.(uid) || null) as TaskItem | null;
	if (!task) return;

	const tmp = document.createElement("div");

	renderTaskTree([task], tmp, app, 0, false, sectionType, selectedAlias);
	const newLi = tmp.querySelector(
		"ul.agile-dashboard.contains-task-list > li"
	) as HTMLElement | null;
	if (!newLi) return;

	li.replaceWith(newLi);
}
./src/features/agile-dashboard-view/app/status-update.ts
import { App, TFile } from "obsidian";
import { TaskItem } from "@features/task-index";
import { hideTaskAndCollapseAncestors } from "../ui/components/task-buttons";
import { eventBus } from "./event-bus";
import {
	DEFAULT_STATUS_SEQUENCE,
	getNextStatusChar,
	advanceTaskStatusForTaskItem,
} from "@features/task-status-sequencer";

/**
 * Toggle or cancel a task's status by delegating to task-status-sequence.
 * - Short press advances via the default sequence: " " → "/" → "x" → "-" → " "
 * - Long press steps through the sequence until it reaches "-"
 *
 * Returns the new status if updated, otherwise null.
 */
export const handleStatusChange = async (
	task: TaskItem,
	liEl: HTMLElement,
	app: App,
	isCancel = false
): Promise<string | null> => {
	try {
		// Resolve file path
		const filePath = task.link?.path || task._uniqueId?.split(":")[0];
		if (!filePath) throw new Error("Missing task file path");

		const file = app.vault.getAbstractFileByPath(filePath) as TFile;
		if (!file) throw new Error(`File not found: ${filePath}`);

		// Prepare optimistic UI suppression for vault modify refresh
		eventBus.dispatch("agile:prepare-optimistic-file-change", { filePath });

		// Read content to robustly locate the target line
		const content = await app.vault.read(file);
		const lines = content.split(/\r?\n/);

		// Helpers (reuse robust targeting from previous implementation)
		const parseStatusFromLine = (line: string): string | null => {
			const m = line.match(/^\s*[-*+]\s*\[\s*(.)\s*\]/);
			return m ? m[1] : null;
		};
		const normalize = (s: string) =>
			(s || "")
				// strip old ✅/❌ markers in comparison context only (not mutating file)
				.replace(/\s*(✅|❌)\s+\d{4}-\d{2}-\d{2}\b/g, "")
				.replace(/\s+/g, " ")
				.trim();
		const getLineRestNormalized = (line: string): string | null => {
			const m = line.match(/^\s*[-*+]\s*\[\s*.\s*\]\s*(.*)$/);
			return m ? normalize(m[1]) : null;
		};

		// Try to resolve the correct line index using provided task hints + text match
		let effectiveStatus = (task.status ?? " ").trim() || " ";
		let targetLineIndex = -1;

		const targetTextNorm = normalize(
			(task.text || task.visual || "").trim()
		);

		// Prefer parsing from known position or nearby
		const baseIdx =
			typeof (task as any)?.position?.start?.line === "number"
				? (task as any).position.start.line
				: typeof task.line === "number"
				? task.line
				: -1;
		const candidates = [baseIdx, baseIdx - 1, baseIdx + 1].filter(
			(i) => i >= 0 && i < lines.length
		);

		for (const i of candidates) {
			const rest = getLineRestNormalized(lines[i]);
			if (!rest) continue;
			if (
				rest === targetTextNorm ||
				rest.startsWith(targetTextNorm) ||
				targetTextNorm.startsWith(rest)
			) {
				targetLineIndex = i;
				const parsed = parseStatusFromLine(lines[i]);
				if (parsed) effectiveStatus = parsed;
				break;
			}
		}

		// Fallback scans
		if (targetLineIndex === -1 && targetTextNorm) {
			// Exact match anywhere
			for (let i = 0; i < lines.length; i++) {
				const rest = getLineRestNormalized(lines[i]);
				if (rest && rest === targetTextNorm) {
					targetLineIndex = i;
					const parsed = parseStatusFromLine(lines[i]);
					if (parsed) effectiveStatus = parsed;
					break;
				}
			}
			// Prefix match anywhere
			if (targetLineIndex === -1) {
				for (let i = 0; i < lines.length; i++) {
					const rest = getLineRestNormalized(lines[i]);
					if (rest && rest.startsWith(targetTextNorm)) {
						targetLineIndex = i;
						const parsed = parseStatusFromLine(lines[i]);
						if (parsed) effectiveStatus = parsed;
						break;
					}
				}
			}
		}

		if (targetLineIndex === -1) {
			// If we absolutely cannot locate the line, abort (avoid unintended edits)
			throw new Error("Unable to locate task line for status change");
		}

		// Predict the next status for short press, or "-" for long press
		const predictShortNext = (cur: string): string =>
			getNextStatusChar(cur as any, DEFAULT_STATUS_SEQUENCE);

		const targetStatus = isCancel ? "-" : predictShortNext(effectiveStatus);

		// Run the update via task-status-sequence, preferring active editor for immediate UX
		// Helper: perform one-step advance
		const stepOnce = async () => {
			await advanceTaskStatusForTaskItem({
				app,
				task: {
					filePath,
					line0: targetLineIndex,
					status: effectiveStatus,
				},
			});
			// Advance our local tracker too for multi-step logic
			effectiveStatus = predictShortNext(effectiveStatus);
		};

		if (isCancel) {
			// Step through the default sequence until we reach '-'
			// Sequence is known: [" ", "/", "x", "-"]
			const seq = DEFAULT_STATUS_SEQUENCE;
			const curIdx = Math.max(
				0,
				seq.findIndex((c) => c === (effectiveStatus as any))
			);
			const targetIdx = seq.findIndex((c) => c === "-");
			const len = seq.length;
			// If current not found (-1), treat as space at 0
			const start = curIdx < 0 ? 0 : curIdx;
			const steps = (targetIdx - start + len) % len;
			for (let i = 0; i < steps; i++) {
				await stepOnce();
			}
		} else {
			// Single step advance
			await stepOnce();
		}

		// Update the TaskItem's in-memory status for immediate UI hints elsewhere
		(task as any).status = targetStatus;

		// Hide completed/cancelled items immediately in UI
		if (targetStatus === "x" || targetStatus === "-") {
			try {
				hideTaskAndCollapseAncestors(liEl);
			} catch {
				/* ignore */
			}
		}

		return targetStatus;
	} catch {
		return null;
	}
};

./src/features/agile-dashboard-view/app/view-orchestration.ts
import type { Container } from "src/composition/container";
import {
	AgileDashboardView,
	VIEW_TYPE_AGILE_DASHBOARD,
} from "src/features/agile-dashboard-view/ui/views/agile-dashboard-view";
import { WorkspaceLeaf } from "obsidian";

/**
 * Register the Agile Dashboard view and associated commands.
 * Keeps registration self-contained so additional feature registrations
 * can be added the same way in the future.
 */
export async function registerAgileDashboardView(container: Container) {
	const { app, plugin } = container;

	plugin.registerView(
		VIEW_TYPE_AGILE_DASHBOARD,
		(leaf: WorkspaceLeaf) =>
			new AgileDashboardView(leaf, {
				taskIndex: container.taskIndexService, // wiring via ports
				settings: container.settingsService, // wiring via ports
				orgStructure: container.orgStructurePorts?.orgStructure, // NEW: org structure
				manifestId: container.manifestId, // NEW: used for storage scoping
			})
	);

	// Helper: open or reveal singleton dashboard leaf
	const openOrRevealDashboard = async () => {
		const existing = app.workspace.getLeavesOfType(
			VIEW_TYPE_AGILE_DASHBOARD
		);
		if (existing.length > 0) {
			// Reveal the first existing dashboard leaf
			app.workspace.revealLeaf(existing[0]);
			return;
		}
		// No existing leaf — create one
		const leaf = app.workspace.getLeaf(true); // create a new leaf only the first time
		await leaf.setViewState({ type: VIEW_TYPE_AGILE_DASHBOARD });
		app.workspace.revealLeaf(leaf);
	};

	// Ensure any open leaves are detached when the plugin unloads
	plugin.register(() => {
		app.workspace.detachLeavesOfType(VIEW_TYPE_AGILE_DASHBOARD);
	});

	// Prune duplicates if they somehow exist (keep the first one)
	const pruneDuplicateDashboardLeaves = () => {
		const leaves = app.workspace.getLeavesOfType(VIEW_TYPE_AGILE_DASHBOARD);
		if (leaves.length > 1) {
			// Keep the first, detach the rest
			for (let i = 1; i < leaves.length; i++) {
				try {
					leaves[i].detach();
				} catch (e) {
					console.warn(
						"Failed to detach duplicate Agile Dashboard leaf",
						e
					);
				}
			}
		}
	};

	// Also run pruning on layout changes as a safety net
	plugin.registerEvent(
		app.workspace.on("layout-change", () => {
			pruneDuplicateDashboardLeaves();
		})
	);

	// Register a simple command to open the dashboard (can be triggered by a status bar click)
	plugin.addCommand({
		id: "agile-open-dashboard",
		name: "Open Agile Dashboard",
		callback: async () => {
			await openOrRevealDashboard();
		},
	});

	// Add a ribbon icon (left sidebar) to open the dashboard
	try {
		const ribbonEl = plugin.addRibbonIcon(
			"list",
			"Open Agile Dashboard",
			async () => {
				await openOrRevealDashboard();
			}
		);
		// Ensure removal on unload
		plugin.register(() => ribbonEl.remove());
	} catch (e) {
		// Not all host environments expose addRibbonIcon; ignore if absent
		console.warn("Could not add ribbon icon for Agile Dashboard", e);
	}

	// Add a status bar item to open the dashboard
	try {
		const statusEl = plugin.addStatusBarItem();
		statusEl.classList.add("agile-dashboard-status");
		statusEl.setAttribute("title", "Open Agile Dashboard");
		statusEl.textContent = "⚡"; // Simple icon — replace with desired markup

		// Use registerDomEvent so it is cleaned up on unload
		plugin.registerDomEvent(statusEl, "click", async () => {
			await openOrRevealDashboard();
		});

		// Also ensure removal on unload
		plugin.register(() => statusEl.remove());
	} catch (e) {
		// addStatusBarItem may not be available in some host environments; ignore gracefully
		console.warn("Could not add status bar item for Agile Dashboard", e);
	}
}

./src/features/agile-dashboard-view/domain/team-selection.ts
import type { SettingsService } from "@settings";
import type { OrgStructurePort } from "@features/org-structure";
import type { TaskItem } from "@features/task-index";

export class TeamSelection {
	private selectedTeamSlugs = new Set<string>();
	private implicitAllSelected = true;
	private readonly storageKey: string;

	constructor(
		private readonly settingsService: SettingsService,
		private readonly orgStructurePort: OrgStructurePort | undefined,
		storageKey: string
	) {
		this.storageKey = storageKey;
		this.load();
	}

	// Persistence
	private load() {
		try {
			const raw = window.localStorage.getItem(this.storageKey);
			if (raw === null) {
				this.implicitAllSelected = true;
				this.selectedTeamSlugs = new Set();
				return;
			}
			this.implicitAllSelected = false;
			const arr = JSON.parse(raw);
			if (Array.isArray(arr)) {
				this.selectedTeamSlugs = new Set(
					arr.map((s) => String(s).toLowerCase())
				);
			} else {
				this.selectedTeamSlugs = new Set();
			}
		} catch {
			this.implicitAllSelected = true;
			this.selectedTeamSlugs = new Set();
		}
	}

	private persist() {
		try {
			this.implicitAllSelected = false;
			const arr = Array.from(this.selectedTeamSlugs.values());
			window.localStorage.setItem(this.storageKey, JSON.stringify(arr));
		} catch {}
	}

	// Public selection API
	getImplicitAllSelected(): boolean {
		return this.implicitAllSelected;
	}
	setImplicitAllSelected(val: boolean) {
		this.implicitAllSelected = val;
	}

	getSelectedTeamSlugs(): Set<string> {
		return this.selectedTeamSlugs;
	}

	addSelectedSlugs(slugs: string[]) {
		slugs.forEach((s) =>
			this.selectedTeamSlugs.add((s || "").toLowerCase())
		);
		this.persist();
	}
	removeSelectedSlugs(slugs: string[]) {
		slugs.forEach((s) =>
			this.selectedTeamSlugs.delete((s || "").toLowerCase())
		);
		this.persist();
	}

	// Membership derivation
	private normalizeAlias(input: string): string {
		if (!input) return "";
		let s = String(input).trim();
		if (s.startsWith("@")) s = s.slice(1);
		return s.toLowerCase();
	}

	private aliasFromMemberLike(x: unknown): string {
		if (typeof x === "string") return this.normalizeAlias(x);
		if (!x || typeof x !== "object") return "";
		const anyObj = x as Record<string, unknown>;
		const cand =
			(anyObj as any).alias ??
			(anyObj as any).user ??
			(anyObj as any).name ??
			(anyObj as any).id ??
			(anyObj as any).email;
		return this.normalizeAlias(
			typeof cand === "string" ? cand : String(cand || "")
		);
	}

	private extractAliases(members: unknown): string[] {
		if (!members) return [];
		if (Array.isArray(members)) {
			return members
				.map((m) => this.aliasFromMemberLike(m))
				.filter(Boolean);
		}
		if (typeof members === "object") {
			return Object.values(members)
				.map((v) => this.aliasFromMemberLike(v))
				.filter(Boolean);
		}
		return [];
	}

	private teamNodeHasUser(node: any, aliasNorm: string): boolean {
		const pools = [
			node?.members,
			node?.memberAliases,
			node?.users,
			node?.aliases,
			node?.membersMap,
			node?.allMembers,
		];
		for (const pool of pools) {
			const aliases = this.extractAliases(pool);
			if (aliases.includes(aliasNorm)) return true;
		}
		return false;
	}

	private tryPortMembershipMethods(aliasNorm: string): Set<string> | null {
		if (!this.orgStructurePort) return null;
		const port = this.orgStructurePort as unknown as Record<
			string,
			unknown
		>;
		const candidates = [
			"getTeamsForUser",
			"getTeamSlugsForUser",
			"getUserTeams",
			"getTeamsByUser",
		];
		for (const fnName of candidates) {
			const fn = port[fnName];
			if (typeof fn === "function") {
				try {
					const raw = (fn as any).call(
						this.orgStructurePort,
						aliasNorm
					);
					if (Array.isArray(raw)) {
						const set = new Set<string>();
						for (const item of raw) {
							if (typeof item === "string") {
								const slug = item.toLowerCase().trim();
								if (slug) set.add(slug);
							} else if (item && typeof item === "object") {
								const cand =
									(item as any).slug ??
									(item as any).teamSlug ??
									(item as any).id ??
									(item as any).key ??
									(item as any).code;
								const slug =
									typeof cand === "string"
										? cand.toLowerCase().trim()
										: String(cand || "")
												.toLowerCase()
												.trim();
								if (slug) set.add(slug);
							}
						}
						if (set.size > 0) return set;
					}
				} catch {
					/* ignore */
				}
			}
		}
		return null;
	}

	private deriveMembershipFromStructure(
		aliasNorm: string
	): Set<string> | null {
		if (!this.orgStructurePort) return null;
		try {
			const { organizations, teams } =
				this.orgStructurePort.getOrgStructure();
			const result = new Set<string>();

			const visitTeam = (node: any) => {
				const cand =
					node?.slug ??
					node?.teamSlug ??
					node?.id ??
					node?.key ??
					node?.code;
				const slug =
					typeof cand === "string"
						? cand.toLowerCase().trim()
						: String(cand || "")
								.toLowerCase()
								.trim();
				if (slug && this.teamNodeHasUser(node, aliasNorm))
					result.add(slug);
				for (const st of (node.subteams as any[] | undefined) || [])
					visitTeam(st);
			};

			for (const org of organizations || [])
				for (const t of org.teams || []) visitTeam(t);
			for (const t of teams || []) visitTeam(t);

			return result.size > 0 ? result : new Set<string>();
		} catch {
			return null;
		}
	}

	private deriveMembershipFromSettings(
		aliasNorm: string
	): Set<string> | null {
		try {
			const settings = this.settingsService.getRaw();
			const teams = settings.teams || [];
			const result = new Set<string>();
			for (const t of teams) {
				const slug = (t as any).slug ?? (t as any).teamSlug ?? "";
				const slugNorm = String(slug || "")
					.toLowerCase()
					.trim();
				if (!slugNorm) continue;
				const members = (t as any).members || [];
				const aliases = this.extractAliases(members);
				if (aliases.includes(aliasNorm)) result.add(slugNorm);
			}
			return result.size > 0 ? result : new Set<string>();
		} catch {
			return null;
		}
	}

	getAllowedTeamSlugsForSelectedUser(
		selectedAlias: string | null
	): Set<string> | null {
		const aliasNorm = this.normalizeAlias(selectedAlias || "");
		if (!aliasNorm) return null;
		const fromPortMethods = this.tryPortMembershipMethods(aliasNorm);
		const fromStructure = this.deriveMembershipFromStructure(aliasNorm);
		const fromSettings = this.deriveMembershipFromSettings(aliasNorm);
		const union = new Set<string>();
		for (const s of [fromPortMethods, fromStructure, fromSettings]) {
			if (!s) continue;
			for (const x of s) union.add(x);
		}
		return union.size > 0 ? union : null;
	}

	restrictSelectedTeamsToUserMembership(selectedAlias: string | null) {
		const allowed = this.getAllowedTeamSlugsForSelectedUser(selectedAlias);
		if (!allowed) return;
		if (this.selectedTeamSlugs.size === 0) return;
		const before = this.selectedTeamSlugs.size;
		for (const s of Array.from(this.selectedTeamSlugs)) {
			if (!allowed.has(s)) this.selectedTeamSlugs.delete(s);
		}
		if (this.selectedTeamSlugs.size !== before) this.persist();
	}

	getTeamSlugForFile(filePath: string): string | null {
		try {
			if (!this.orgStructurePort) return null;
			const { team } =
				this.orgStructurePort.getTeamMembersForFile(filePath);
			const slug = (team?.slug || "").toLowerCase().trim();
			return slug || null;
		} catch {
			return null;
		}
	}

	isTaskAllowedByTeam(task: TaskItem, selectedAlias: string | null): boolean {
		const filePath =
			task.link?.path || (task._uniqueId?.split(":")[0] ?? "");
		if (!filePath) return false;

		const allowedByUser =
			this.getAllowedTeamSlugsForSelectedUser(selectedAlias);

		if (this.implicitAllSelected) {
			if (!this.orgStructurePort) return true;
			const teamSlug = this.getTeamSlugForFile(filePath);
			if (!allowedByUser) return true;
			if (!teamSlug) return false;
			return allowedByUser.has(teamSlug);
		}

		if (this.selectedTeamSlugs.size === 0) return false;

		const teamSlug = this.getTeamSlugForFile(filePath);
		if (!teamSlug) return false;

		const inSelected = this.selectedTeamSlugs.has(teamSlug);
		if (!inSelected) return false;

		if (allowedByUser) return allowedByUser.has(teamSlug);
		return true;
	}

	// Expose state for Teams popup
	buildTeamsPopupContext() {
		return {
			selectedTeamSlugs: this.selectedTeamSlugs,
			implicitAllSelected: this.implicitAllSelected,
		};
	}
}

./src/features/agile-dashboard-view/domain/view-state.ts
export type SelectedView = "projects" | "completed";

export interface DashboardState {
	selectedView: SelectedView;
	activeOnly: boolean;
	selectedAlias: string | null;
}

./src/features/agile-dashboard-view/index.ts
export { registerAgileDashboardView } from "./app/view-orchestration";

export { type TaskUIPolicy, normalizeSection } from "./ui/components/ui-policy";
./src/features/agile-dashboard-view/ui/components/artifacts.ts
import { App } from "obsidian";
import { TaskItem, TaskParams } from "@features/task-index";
import { renderTaskTree } from "./task-renderer";
import { activeForMember, getAgileArtifactType } from "@features/task-filter";
import { buildPrunedMergedTrees } from "@features/task-tree-builder";
import type { AgileObsidianSettings } from "@settings/index";
import { isShownByParams } from "../utils/filters";
import { attachSectionFolding } from "@features/task-tree-fold";
import { normalizeSection } from "./ui-policy";

export type ArtifactPredicate = (
	task: TaskItem,
	taskMap: Map<string, TaskItem>
) => boolean;

export interface ArtifactOptions {
	title: string;
	renderType: string; // passed to renderTaskTree and used for folding sectionName
	predicate: ArtifactPredicate;
}

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

/**
Create a per-section root wrapper to isolate DOM for Tasks/Stories/Epics,
render the section inside it, wire folding, and then "re-stamp" all task list
nodes in this section with the normalized section name to prevent any
post-processing code from accidentally overriding the data-section.
*/
export function processAndRenderArtifact(
	container: HTMLElement,
	currentTasks: TaskItem[],
	status: boolean,
	selectedAlias: string | null,
	app: App,
	taskMap: Map<string, TaskItem>,
	childrenMap: Map<string, TaskItem[]>,
	taskParams: TaskParams,
	options: ArtifactOptions,
	registerDomEvent?: RegisterDomEvent
) {
	const sectionTasks = currentTasks.filter((task) =>
		isShownByParams(task, taskMap, selectedAlias, taskParams)
	);

	const directlyAssigned = sectionTasks.filter(
		(task) =>
			activeForMember(task, status, selectedAlias) &&
			options.predicate(task, taskMap)
	);

	const prunedTasks = buildPrunedMergedTrees(directlyAssigned, taskMap);

	if (prunedTasks.length > 0) {
		// Normalize once and keep it consistent
		const normalizedType = normalizeSection(options.renderType);

		// Create an isolated root wrapper for this artifact section
		const sectionRoot = container.createEl("div", {
			cls: "agile-artifact-section",
			attr: {
				"data-section-root": normalizedType,
			},
		});

		// Heading
		sectionRoot.createEl("h2", { text: options.title });

		// Render into the section root
		renderTaskTree(
			prunedTasks,
			sectionRoot,
			app,
			0,
			false,
			normalizedType,
			selectedAlias
		);

		// Wire folding, scoped to this section only
		try {
			attachSectionFolding(sectionRoot, {
				app,
				taskMap,
				childrenMap,
				selectedAlias,
				renderTaskTree,
				registerDomEvent,
				sectionName: normalizedType,
				// No first-level gating for Tasks/Stories/Epics; bottom-only rule enforced by fold module.
			});
		} catch {
			/* ignore */
		}

		// Final pass: enforce correct data-section stamping across all lists/items
		// in this section only (protect against any accidental overrides elsewhere).
		try {
			const restamp = (root: HTMLElement, value: string) => {
				const uls = Array.from(
					root.querySelectorAll(
						"ul.agile-dashboard.contains-task-list"
					)
				) as HTMLElement[];
				uls.forEach((ul) => ul.setAttribute("data-section", value));

				const lis = Array.from(
					root.querySelectorAll("li.task-list-item")
				) as HTMLElement[];
				lis.forEach((li) => li.setAttribute("data-section", value));
			};
			restamp(sectionRoot, normalizedType);
		} catch {
			/* ignore */
		}
	}
}

/**
Render all artifacts sections that are enabled in settings.
*/
export function processAndRenderArtifacts(
	container: HTMLElement,
	currentTasks: TaskItem[],
	status: boolean,
	selectedAlias: string | null,
	app: App,
	taskMap: Map<string, TaskItem>,
	childrenMap: Map<string, TaskItem[]>,
	taskParams: TaskParams,
	settings: AgileObsidianSettings,
	registerDomEvent?: RegisterDomEvent
) {
	if (settings.showTasks) {
		processAndRenderArtifact(
			container,
			currentTasks,
			status,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			{
				title: "🔨 Tasks",
				renderType: "tasks",
				predicate: (t) => getAgileArtifactType(t) === "task",
			},
			registerDomEvent
		);
	}
	if (settings.showStories) {
		processAndRenderArtifact(
			container,
			currentTasks,
			status,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			{
				title: "📝 Stories",
				renderType: "stories",
				predicate: (t) => getAgileArtifactType(t) === "story",
			},
			registerDomEvent
		);
	}
	if (settings.showEpics) {
		processAndRenderArtifact(
			container,
			currentTasks,
			status,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			{
				title: "🏆 Epics",
				renderType: "epics",
				predicate: (t) => getAgileArtifactType(t) === "epic",
			},
			registerDomEvent
		);
	}
}

./src/features/agile-dashboard-view/ui/components/controls-bar.ts
import type { SettingsService } from "@settings";
import { buildGroupedMemberSelect } from "./member-select";

export interface ControlsBarOptions {
	container: HTMLElement;
	version: string;
	settingsService: SettingsService;
	initialView: "projects" | "completed";
	initialActiveOnly: boolean;
	initialAlias: string | null;
	onViewChange: (v: "projects" | "completed") => void;
	onActiveToggleChange: (active: boolean) => void;
	onMemberChange: (alias: string | null) => void;
	onSelectTeamsClick: (anchor: HTMLElement) => void;
	/** New: trigger a full task-index rebuild */
	onRebuildIndexClick: () => void;
}

export interface ControlsBarRefs {
	root: HTMLElement;
	viewSelect: HTMLSelectElement;
	activeToggle: HTMLInputElement;
	activeToggleLabel: HTMLSpanElement;
	memberSelect: HTMLSelectElement;
	selectTeamsBtn: HTMLButtonElement;
	rebuildBtn: HTMLButtonElement;
}

export function renderControlsBar(opts: ControlsBarOptions): ControlsBarRefs {
	const {
		container,
		version,
		settingsService,
		initialView,
		initialActiveOnly,
		initialAlias,
		onViewChange,
		onActiveToggleChange,
		onMemberChange,
		onSelectTeamsClick,
		onRebuildIndexClick,
	} = opts;

	const controlsContainer = container.createEl("div", {
		attr: {
			style: "display:flex; align-items:center; gap:8px; position:relative; flex-wrap:wrap;",
		},
	});

	// Version
	const versionText = controlsContainer.createEl("p");
	const strongText = versionText.createEl("strong");
	strongText.textContent = `Agile Obsidian v${version}`;

	// Rebuild index icon button (moved here: right after version text)
	const rebuildBtn = controlsContainer.createEl("button", {
		text: "↻",
	}) as HTMLButtonElement;
	rebuildBtn.title = "Rebuild Task Index";
	rebuildBtn.setAttribute("aria-label", "Rebuild Task Index");
	rebuildBtn.addEventListener("click", (ev) => {
		ev.preventDefault();
		ev.stopPropagation();
		onRebuildIndexClick();
	});

	// View selector comes after the rebuild button
	const viewSelect = controlsContainer.createEl("select");
	viewSelect.innerHTML = `
    <option value="projects">🚀 Projects</option>
    <option value="completed">✅ Completed</option>
  `;
	viewSelect.value = initialView;
	viewSelect.addEventListener("change", () => {
		onViewChange(
			(viewSelect.value as "projects" | "completed") ?? "projects"
		);
	});

	// Member selector
	const memberSelect = buildGroupedMemberSelect(
		settingsService,
		initialAlias
	);
	memberSelect.addEventListener("change", () => {
		onMemberChange(memberSelect.value || null);
	});
	controlsContainer.appendChild(memberSelect);

	// Team selection button
	const selectTeamsBtn = controlsContainer.createEl("button", {
		text: "Select Teams",
	}) as HTMLButtonElement;
	selectTeamsBtn.addEventListener("click", (ev) => {
		ev.preventDefault();
		ev.stopPropagation();
		onSelectTeamsClick(selectTeamsBtn);
	});

	// Active/Inactive toggle
	const statusToggleContainer = controlsContainer.createEl("span", {
		attr: { style: "display:inline-flex; align-items:center; gap:6px;" },
	});
	const activeToggleLabel = statusToggleContainer.createEl("span", {
		text: initialActiveOnly ? "Active" : "Inactive",
	});
	const activeToggle = statusToggleContainer.createEl("input", {
		type: "checkbox",
	}) as HTMLInputElement;
	activeToggle.checked = initialActiveOnly;
	statusToggleContainer.style.display =
		initialView === "projects" ? "inline-flex" : "none";

	activeToggle.addEventListener("change", () => {
		activeToggleLabel.textContent = activeToggle.checked
			? "Active"
			: "Inactive";
		onActiveToggleChange(activeToggle.checked);
	});

	viewSelect.addEventListener("change", () => {
		statusToggleContainer.style.display =
			viewSelect.value === "projects" ? "inline-flex" : "none";
	});

	return {
		root: controlsContainer,
		viewSelect,
		activeToggle,
		activeToggleLabel,
		memberSelect,
		selectTeamsBtn,
		rebuildBtn,
	};
}

./src/features/agile-dashboard-view/ui/components/initiatives.ts
import { App } from "obsidian";
import { TaskItem, TaskParams } from "@features/task-index";
import { renderTaskTree } from "./task-renderer";
import { activeForMember, getAgileArtifactType } from "@features/task-filter";
import { buildPrunedMergedTrees } from "@features/task-tree-builder";
import { isShownByParams } from "../utils/filters";
import { attachSectionFolding } from "@features/task-tree-fold";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

/**
 * Process and render the Initiatives section.
 * Displays top-level initiatives. Expanding an initiative shows only its direct epics.
 * Each expanded level renders ONLY direct children (filtered) and adds recursive chevrons.
 */
export function processAndRenderInitiatives(
	container: HTMLElement,
	currentTasks: TaskItem[],
	status: boolean,
	selectedAlias: string | null,
	app: App,
	taskMap: Map<string, TaskItem>,
	childrenMap: Map<string, TaskItem[]>,
	taskParams: TaskParams,
	registerDomEvent?: RegisterDomEvent
) {
	// 1) Filter to tasks shown by current view toggles
	const sectionTasks = currentTasks.filter((task) =>
		isShownByParams(task, taskMap, selectedAlias, taskParams)
	);

	// 2) Only initiatives assigned/active for member
	const directlyAssigned = sectionTasks.filter(
		(task) =>
			activeForMember(task, status, selectedAlias) &&
			getAgileArtifactType(task) === "initiative"
	);

	// Build ONLY the initiatives (no children) so epics are hidden by default
	const initiativesOnly = buildPrunedMergedTrees(
		directlyAssigned,
		taskMap,
		undefined,
		childrenMap,
		{ depth: 0 }
	);

	if (initiativesOnly.length > 0) {
		container.createEl("h2", { text: "🎖️ Initiatives" });

		// Render initiatives with no children
		renderTaskTree(
			initiativesOnly,
			container,
			app,
			0,
			false,
			"initiatives",
			selectedAlias
		);

		// Attach folding toggles via reusable fold module (section-agnostic API)
		try {
			attachSectionFolding(container, {
				app,
				taskMap,
				childrenMap,
				selectedAlias,
				renderTaskTree,
				registerDomEvent,
				sectionName: "initiatives",
				firstLevelChildType: "epic",
			});
		} catch {
			/* ignore */
		}
	}
}

./src/features/agile-dashboard-view/ui/components/member-select.ts
import type { SettingsService } from "@settings";

export function buildGroupedMemberSelect(
	settingsService: SettingsService,
	initialAlias: string | null
): HTMLSelectElement {
	const select = document.createElement("select");

	type Entry = {
		alias: string;
		name: string;
		role: "member" | "internal-team-member" | "team" | "external";
		label: string;
	};

	const entries: Entry[] = [];
	const seen = new Set<string>();

	const normalizeAlias = (input: string): string => {
		if (!input) return "";
		let s = String(input).trim();
		if (s.startsWith("@")) s = s.slice(1);
		return s.toLowerCase();
	};

	const settings = settingsService.getRaw();
	const teams = settings.teams || [];

	for (const t of teams) {
		for (const m of t.members || []) {
			const aliasRaw =
				typeof m === "string"
					? m
					: (m as any)?.alias || (m as any)?.name || "";
			const alias = normalizeAlias(aliasRaw);
			if (!alias) continue;
			if (seen.has(alias)) continue;
			seen.add(alias);

			const dispName =
				(typeof m === "string" ? "" : (m as any)?.name) || alias;

			const lower = alias.toLowerCase();
			let role: Entry["role"] = "member";
			if (lower.endsWith("-ext")) role = "external";
			else if (lower.endsWith("-team")) role = "team";
			else if (lower.endsWith("-int")) role = "internal-team-member";

			const roleLabel =
				role === "member"
					? "Team Member"
					: role === "internal-team-member"
					? "Internal Team Member"
					: role === "team"
					? "Internal Team"
					: "External Delegate";

			const label = `${dispName} (${roleLabel} - ${alias})`;
			entries.push({ alias, name: dispName, role, label });
		}
	}

	const groupTeamMembers = entries
		.filter((e) => e.role === "member" || e.role === "internal-team-member")
		.sort((a, b) => a.name.localeCompare(b.name));
	const groupDelegatesInternalTeams = entries
		.filter((e) => e.role === "team")
		.sort((a, b) => a.name.localeCompare(b.name));
	const groupDelegatesExternal = entries
		.filter((e) => e.role === "external")
		.sort((a, b) => a.name.localeCompare(b.name));

	const addGroup = (label: string, group: Entry[]) => {
		if (group.length === 0) return;
		const og = document.createElement("optgroup");
		og.label = label;
		group.forEach((e) => {
			const opt = document.createElement("option");
			opt.value = e.alias;
			opt.text = e.label;
			og.appendChild(opt);
		});
		select.appendChild(og);
	};

	addGroup("Team Members", groupTeamMembers);
	addGroup("Delegates – Internal Teams", groupDelegatesInternalTeams);
	addGroup("Delegates – External", groupDelegatesExternal);

	const defRaw = settings.currentUserAlias || "";
	const def = normalizeAlias(defRaw);
	const all = [
		...groupTeamMembers,
		...groupDelegatesInternalTeams,
		...groupDelegatesExternal,
	];

	const preferred =
		initialAlias && all.some((e) => e.alias === initialAlias)
			? initialAlias
			: def && all.some((e) => e.alias === def)
			? def
			: all[0]?.alias ?? "";
	if (preferred) select.value = preferred;

	return select;
}

./src/features/agile-dashboard-view/ui/components/objectives.ts
import { App } from "obsidian";
import { TaskItem, TaskParams } from "@features/task-index";
import { renderTaskTree } from "./task-renderer";
import { activeForMember, getAgileArtifactType } from "@features/task-filter";
import { buildPrunedMergedTrees } from "@features/task-tree-builder";
import { isShownByParams } from "../utils/filters";
import { attachSectionFolding } from "@features/task-tree-fold";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

/**
Process and render Objectives (OKRs) and their linked item trees.
Folding behavior:
- Render objectives (OKRs) without their native children, and enable fold/unfold on the OKR itself.
- In the "Linked Items" section, only add fold toggles on bottom-level items currently displayed.
*/
export function processAndRenderObjectives(
	container: HTMLElement,
	currentTasks: TaskItem[],
	status: boolean,
	selectedAlias: string | null,
	app: App,
	taskMap: Map<string, TaskItem>,
	childrenMap: Map<string, TaskItem[]>,
	taskParams: TaskParams,
	registerDomEvent?: RegisterDomEvent
) {
	const sectionTasks = currentTasks.filter((task) =>
		isShownByParams(task, taskMap, selectedAlias, taskParams)
	);

	const assignedOKRs = sectionTasks.filter(
		(task) =>
			getAgileArtifactType(task) === "okr" &&
			activeForMember(task, status, selectedAlias)
	);
	const assignedOKRSet = new Set(assignedOKRs.map((t) => t._uniqueId ?? ""));

	const findLinkedOKRs = (okrSet: Set<string>) => {
		const linkedOKRs: { _uniqueId: string; linkedTasks: TaskItem[] }[] = [];
		const assignedOKRIds = Array.from(okrSet);

		assignedOKRIds.forEach((okrId) => {
			const okrTask = taskMap.get(okrId);
			if (!okrTask) return;

			const sixDigitCode = okrTask.blockId;
			if (!sixDigitCode || !/^[A-Za-z0-9]{6}$/.test(sixDigitCode)) {
				return;
			}

			const linkedPattern = new RegExp(`${sixDigitCode}">🔗🎯`);
			const rawLinked = sectionTasks.filter((t) =>
				linkedPattern.test(t.text)
			);
			if (!rawLinked.length) return;
			linkedOKRs.push({ _uniqueId: okrId, linkedTasks: rawLinked });
		});

		return linkedOKRs;
	};
	const linkedOKRs = findLinkedOKRs(assignedOKRSet);

	const prunedOKRs = linkedOKRs
		.map((entry) => {
			const okr = taskMap.get(entry._uniqueId);
			if (!okr) return null;

			const linkedTrees = buildPrunedMergedTrees(
				entry.linkedTasks,
				taskMap
			);

			const linkedIds = new Set(
				entry.linkedTasks.map((t) => t._uniqueId ?? "")
			);

			const updateStatusDFS = (node: TaskItem) => {
				if (linkedIds.has(node._uniqueId ?? "")) {
					node.status = "p";
					if (node.visual) {
						node.visual = node.visual.replace(
							/-\s*\[\s*.\s*\]/,
							"- [p]"
						);
					}
				}
				node.children?.forEach((child) => updateStatusDFS(child));
			};
			linkedTrees.forEach((tree) => updateStatusDFS(tree));

			const getTreeLeaves = (
				node: TaskItem,
				leaves: TaskItem[] = []
			): TaskItem[] => {
				if (!node.children || node.children.length === 0) {
					leaves.push(node);
				} else {
					node.children.forEach((child) =>
						getTreeLeaves(child, leaves)
					);
				}
				return leaves;
			};

			const getTreePriority = (tree: TaskItem): number => {
				const leaves = getTreeLeaves(tree);
				const hasActive = leaves.some((leaf) =>
					activeForMember(leaf, true)
				);
				if (hasActive) return 1;
				const hasInactive = leaves.some((leaf) =>
					activeForMember(leaf, false)
				);
				if (hasInactive) return 2;
				return 3;
			};

			linkedTrees.sort((a, b) => getTreePriority(a) - getTreePriority(b));

			return { okr, linkedTrees };
		})
		.filter(
			(item): item is { okr: TaskItem; linkedTrees: TaskItem[] } =>
				item !== null
		);

	if (prunedOKRs.length > 0 && status) {
		container.createEl("h2", { text: "🎯 Objectives" });

		prunedOKRs.forEach(({ okr, linkedTrees }) => {
			// Render the OKR itself without its native children;
			// folding will be enabled on the objective to unfold its task tree.
			const okrShallow: TaskItem = { ...okr, children: [] };
			renderTaskTree(
				[okrShallow],
				container,
				app,
				0,
				false,
				"objectives",
				selectedAlias
			);

			// Folding on the OKR itself
			try {
				attachSectionFolding(container, {
					app,
					taskMap,
					childrenMap,
					selectedAlias,
					renderTaskTree,
					registerDomEvent,
					sectionName: "objectives",
				});
			} catch {
				/* ignore */
			}

			// Linked trees (as-is), with folding only on bottom-level nodes currently displayed.
			container.createEl("h5", {
				text: "🔗 Linked Items",
				attr: { style: "margin-left: 20px;" },
			});

			const indentedWrapper = container.createEl("div", {
				attr: { style: "padding-left: 20px;" },
			});
			renderTaskTree(
				linkedTrees,
				indentedWrapper,
				app,
				0,
				false,
				"objectives-linked",
				selectedAlias
			);

			try {
				attachSectionFolding(indentedWrapper, {
					app,
					taskMap,
					childrenMap,
					selectedAlias,
					renderTaskTree,
					registerDomEvent,
					sectionName: "objectives-linked",
				});
			} catch {
				/* ignore */
			}
		});
	}
}

./src/features/agile-dashboard-view/ui/components/priorities.ts
import { App } from "obsidian";
import { TaskItem, TaskParams } from "@features/task-index";
import { renderTaskTree } from "./task-renderer";
import {
	activeForMember,
	isCancelled,
	isInProgress,
	isCompleted,
	isSnoozed,
	getAgileArtifactType,
} from "@features/task-filter";
import { isRelevantToday } from "@features/task-date-manager";
import { stripListItems } from "@features/task-tree-builder";
import { attachSectionFolding } from "@features/task-tree-fold";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

/**
Process and render the Priorities section (time-relevant task trees).
New: Enable folding on bottom-level items to allow further subtasks expansion.
*/
export function processAndRenderPriorities(
	container: HTMLElement,
	currentTasks: TaskItem[],
	status: boolean,
	selectedAlias: string | null,
	app: App,
	taskMap: Map<string, TaskItem>,
	childrenMap: Map<string, TaskItem[]>,
	taskParams: TaskParams,
	registerDomEvent?: RegisterDomEvent
) {
	const { inProgress, completed, sleeping, cancelled } = taskParams;

	const buildPriorityTree = (
		task: TaskItem,
		isRoot = false
	): TaskItem | null => {
		if (isSnoozed(task, taskMap, selectedAlias)) return null;

		const allowedMarkers = ["🚀", "📦", "⚡", "⭐", "💝", "⬇️", "🪣"];
		const disallowedMarkers = ["❌", "🛠️", "📂", "🏆", "📝", "🎖️"];

		if (disallowedMarkers.some((m) => task.text.includes(m))) return null;
		if (
			getAgileArtifactType(task) === "learning-initiative" ||
			getAgileArtifactType(task) === "learning-epic"
		)
			return null;

		const hasAllowedMarker = allowedMarkers.some((m) =>
			task.text.includes(m)
		);
		const hasAllowedStatus = task.status === "d" || task.status === "A";

		if (!isRoot && !hasAllowedMarker && !hasAllowedStatus) return null;

		const children = (task.children || [])
			.map((child: TaskItem) => buildPriorityTree(child, false))
			.filter((c): c is TaskItem => c !== null);

		if (task.task === false) {
			return children.length > 0 ? { ...task, children } : null;
		}

		const hasAllowed = hasAllowedMarker || hasAllowedStatus;
		const assignedToMe = activeForMember(task, status, selectedAlias);
		if (!hasAllowed && children.length === 0 && !assignedToMe) {
			return null;
		}

		return { ...task, children };
	};

	const priorityRoots = currentTasks.filter(
		(task: TaskItem) =>
			task.status === "O" &&
			!task.completed &&
			isRelevantToday(task) &&
			!isCancelled(task) &&
			!task.text.includes("🎖️") &&
			!task.text.includes("🏆") &&
			!task.text.includes("📝") &&
			!isSnoozed(task, taskMap, selectedAlias) &&
			getAgileArtifactType(task) !== "recurring-responsibility"
	);

	const rawTreesPriorities = priorityRoots
		.map((task: TaskItem) => buildPriorityTree(task, true))
		.filter((tree): tree is TaskItem => tree !== null);

	const prunePriorities = (
		node: TaskItem,
		inherited = false
	): TaskItem | null => {
		const assignedToSelected = activeForMember(node, status, selectedAlias);
		const isInherited = inherited || assignedToSelected;
		const children = (node.children || [])
			.map((child: TaskItem) => prunePriorities(child, isInherited))
			.filter((c): c is TaskItem => c !== null);
		if (isInherited || children.length > 0) {
			return { ...node, children };
		}
		return null;
	};

	const priorityTasks = rawTreesPriorities
		.map((tree: TaskItem) => prunePriorities(tree))
		.filter((tree): tree is TaskItem => tree !== null)
		.filter((tree: TaskItem) => {
			if (!selectedAlias) return true;
			const isSelected = activeForMember(tree, status, selectedAlias);
			return isSelected || (tree.children?.length ?? 0) > 0;
		});

	const strippedPriorityTasks = stripListItems(priorityTasks);

	const filteredPriorityTasks = strippedPriorityTasks.filter((task) => {
		return (
			(inProgress && isInProgress(task, taskMap, selectedAlias)) ||
			(completed && isCompleted(task)) ||
			(sleeping && isSnoozed(task, taskMap, selectedAlias)) ||
			(cancelled && isCancelled(task))
		);
	});

	if (filteredPriorityTasks.length > 0 && status) {
		container.createEl("h2", { text: "📂 Priorities" });
		renderTaskTree(
			filteredPriorityTasks,
			container,
			app,
			0,
			false,
			"priorities",
			selectedAlias
		);

		// Add folding for bottom-level items
		try {
			attachSectionFolding(container, {
				app,
				taskMap,
				childrenMap,
				selectedAlias,
				renderTaskTree,
				registerDomEvent,
				sectionName: "priorities",
			});
		} catch {
			/* ignore */
		}
	}
}

./src/features/agile-dashboard-view/ui/components/responsibilities.ts
import { App } from "obsidian";
import { TaskItem, TaskParams } from "@features/task-index";
import { renderTaskTree } from "./task-renderer";
import {
	activeForMember,
	isCancelled,
	isInProgress,
	isCompleted,
	isSnoozed,
	getAgileArtifactType,
	isAssignedToMemberOrTeam,
	isAssignedToAnyUser,
} from "@features/task-filter";
import { isRelevantToday, recurringPatternMatchesToday } from "@features/task-date-manager";
import { buildFullSubtree } from "@features/task-tree-builder";
import { attachSectionFolding } from "@features/task-tree-fold";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

/**
Process and render recurring Responsibilities assigned to the selected member/team.

New behavior:
- Show only the responsibility itself (no pre-expanded children).
- Add fold/unfold on the responsibility item to reveal its children.
- We DO NOT fold away higher-level ancestors in its task tree.
*/
export function processAndRenderResponsibilities(
	container: HTMLElement,
	currentTasks: TaskItem[],
	status: boolean,
	selectedAlias: string | null,
	app: App,
	taskMap: Map<string, TaskItem>,
	childrenMap: Map<string, TaskItem[]>,
	taskParams: TaskParams,
	registerDomEvent?: RegisterDomEvent
) {
	void childrenMap;

	const { inProgress, completed, sleeping, cancelled } = taskParams;

	const isAssignedToMemberIncludingInferred = (task: TaskItem) => {
		if (isAssignedToMemberOrTeam(task, selectedAlias)) return true;

		let cur: TaskItem | undefined = task;
		while (cur?._parentId) {
			const parentId = cur._parentId;
			if (!parentId) return false;
			cur = taskMap.get(parentId);
			if (!cur) return false;

			if (isAssignedToAnyUser(cur)) {
				return activeForMember(cur, status, selectedAlias);
			}
		}
		return false;
	};

	const collectRecurring = (node: TaskItem, collector: TaskItem[]) => {
		if (
			getAgileArtifactType(node) === "recurring-responsibility" &&
			isAssignedToMemberIncludingInferred(node) &&
			!isSnoozed(node, taskMap, selectedAlias)
		) {
			collector.push(node);
		}
		(node.children || []).forEach((child: TaskItem) =>
			collectRecurring(child, collector)
		);
	};

	// Identify relevant roots (top-down priorities filter, as before)
	const priorityRoots = currentTasks.filter(
		(task) =>
			task.status === "O" &&
			!task.completed &&
			isRelevantToday(task) &&
			!isCancelled(task) &&
			!task.text.includes("🎖️") &&
			!task.text.includes("🏆") &&
			!task.text.includes("📝") &&
			!isSnoozed(task, taskMap, selectedAlias) &&
			getAgileArtifactType(task) !== "recurring-responsibility"
	);

	const priorityTrees = priorityRoots.map((t) => buildFullSubtree(t));

	// Gather recurring responsibilities present in the subtree of today's relevant items
	let allRecurring: TaskItem[] = [];
	priorityTrees.forEach((tree: TaskItem) =>
		collectRecurring(tree, allRecurring)
	);

	// Respect DOW schedules like "🗓️ Sundays"
	allRecurring = allRecurring.filter((task) => {
		const hasCalendar = /🗓️/.test(task.text);
		return !hasCalendar || recurringPatternMatchesToday(task);
	});

	// Unique by _uniqueId
	const seen = new Set<string>();
	const uniqueRecurring: TaskItem[] = [];
	for (const r of allRecurring) {
		const id = r._uniqueId ?? "";
		if (!id || seen.has(id)) continue;
		seen.add(id);
		uniqueRecurring.push(r);
	}

	// Apply status filters to the responsibility itself (no children considered here)
	const responsibilityItemsFiltered = uniqueRecurring.filter((task) => {
		return (
			(inProgress && isInProgress(task, taskMap, selectedAlias)) ||
			(completed && isCompleted(task)) ||
			(sleeping && isSnoozed(task, taskMap, selectedAlias)) ||
			(cancelled && isCancelled(task))
		);
	});

	if (responsibilityItemsFiltered.length > 0 && status) {
		container.createEl("h2", { text: "🧹 Responsibilities" });

		// Render just the responsibility items themselves (no pre-rendered children)
		const shallowOnly = responsibilityItemsFiltered.map((t) => ({
			...t,
			children: [],
		}));
		renderTaskTree(
			shallowOnly,
			container,
			app,
			0,
			false,
			"responsibilities",
			selectedAlias
		);

		// Enable folding on these bottom-level responsibility items
		try {
			attachSectionFolding(container, {
				app,
				taskMap,
				childrenMap,
				selectedAlias,
				renderTaskTree,
				registerDomEvent,
				sectionName: "responsibilities",
			});
		} catch {
			/* ignore */
		}
	}
}

./src/features/agile-dashboard-view/ui/components/task-buttons.ts
/**
 * Adapter: delegates task button logic to the task-buttons feature,
 * injecting the Agile Dashboard event bus for optimistic updates.
 *
 * Updated to use the new task-buttons orchestration factory and API.
 */

import type { App } from "obsidian";
import type { TaskItem } from "@features/task-index";
import { eventBus } from "../../app/event-bus";
import { createObsidianTaskButtonsAPI } from "@features/task-buttons";
import { hideTaskAndCollapseAncestors as hideGeneric } from "@features/task-buttons";

// Cache a per-App API instance to avoid repeated construction.
const apiCache = new WeakMap<
	App,
	ReturnType<typeof createObsidianTaskButtonsAPI>
>();

function getAPI(app: App) {
	let api = apiCache.get(app);
	if (!api) {
		api = createObsidianTaskButtonsAPI(app, eventBus);
		apiCache.set(app, api);
	}
	return api;
}

export function hideTaskAndCollapseAncestors(liEl: HTMLElement): void {
	hideGeneric(liEl);
}

export async function appendSnoozeButtonIfEligible(
	task: TaskItem,
	liEl: HTMLElement,
	sectionType: string,
	app: App,
	selectedAlias: string | null
): Promise<void> {
	const api = getAPI(app);
	await api.appendSnoozeButtonIfEligible(
		task,
		liEl,
		sectionType,
		selectedAlias ?? ""
	);
}

export async function appendSnoozeAllSubtasksButtonIfEligible(
	task: TaskItem,
	liEl: HTMLElement,
	sectionType: string,
	app: App,
	selectedAlias: string | null
): Promise<void> {
	const api = getAPI(app);
	await api.appendSnoozeAllSubtasksButtonIfEligible(
		task,
		liEl,
		sectionType,
		selectedAlias ?? ""
	);
}

./src/features/agile-dashboard-view/ui/components/task-renderer.ts
import { App, Component, MarkdownRenderer, TFile } from "obsidian";
import { TaskItem } from "@features/task-index";
import {
	appendSnoozeButtonIfEligible,
	appendSnoozeAllSubtasksButtonIfEligible,
} from "./task-buttons";
import { normalizeSection as normalizeSectionPolicy } from "./ui-policy";
import { eventBus } from "../../app/event-bus";
import {
	attachCustomCheckboxStatusHandlers,
	StatusChar,
} from "@features/task-status-sequencer";
import { hideTaskAndCollapseAncestors } from "./task-buttons";

function isLeaf(task: TaskItem): boolean {
	return !task.children || task.children.length === 0;
}

function normalizeSection(sectionType: string) {
	return normalizeSectionPolicy(sectionType);
}

function shouldEnableCheckbox(
	sectionType: string,
	depth: number,
	task: TaskItem,
	isRoot: boolean
): boolean {
	const section = normalizeSection(sectionType);
	const leaf = isLeaf(task);

	if (section === "initiatives") return true;
	if (section === "objectives" || section === "objectives-linked")
		return (isRoot && depth === 0) || leaf;
	if (
		section === "tasks" ||
		section === "stories" ||
		section === "epics" ||
		section === "priorities" ||
		section === "responsibilities"
	) {
		return leaf;
	}
	return true;
}

let assignmentEventListenerAttached = false;
function ensureAssignmentEventListener(app: App) {
	if (assignmentEventListenerAttached) return;
	assignmentEventListenerAttached = true;

	eventBus.on("agile:request-assign-propagate", async (detail) => {
		try {
			const uid = detail?.uid;
			const newAlias = detail?.newAlias;
			if (
				typeof uid === "string" &&
				typeof newAlias === "string" &&
				uid
			) {
				const filePath = uid.split(":")[0] || "";
				if (filePath) {
					eventBus.dispatch("agile:prepare-optimistic-file-change", {
						filePath,
					});
					eventBus.dispatch("agile:assignment-changed", {
						uid,
						filePath,
						newAlias,
					});
				}
			}
		} catch {
			/* ignore */
		}
	});
}

function annotateAssigneeMarks(
	liEl: HTMLElement,
	uid: string,
	filePath: string
) {
	const marks = liEl.querySelectorAll("mark");
	marks.forEach((m) => {
		const el = m as HTMLElement;
		const cls = (el.getAttribute("class") || "").toLowerCase();
		if (
			!/(^|\s)(?:active|inactive)-[a-z0-9-]+(\s|$)/i.test(" " + cls + " ")
		)
			return;
		const strong = el.querySelector("strong");
		if (!strong || !/^\s*👋/u.test(strong.textContent || "")) return;
		el.setAttribute("data-task-uid", uid);
		if (filePath) el.setAttribute("data-file-path", filePath);
	});
}

/**
 * Utilities for opening a task's source file at its line in a new tab (leaf)
 */
function getTaskFilePath(task: TaskItem): string {
	return task.link?.path || (task._uniqueId?.split(":")[0] ?? "");
}

function getTaskLine(task: TaskItem): number | null {
	const posLine = (task as any)?.position?.start?.line ?? (task as any)?.line;
	if (typeof posLine === "number" && posLine >= 0) return posLine;
	if (typeof task.line === "number" && task.line >= 0) return task.line;
	return null;
}

async function openTaskInNewTab(app: App, task: TaskItem): Promise<void> {
	try {
		const filePath = getTaskFilePath(task);
		if (!filePath) return;

		const abs = app.vault.getAbstractFileByPath(filePath);
		if (!(abs instanceof TFile)) return;

		const line = getTaskLine(task);
		const leaf = app.workspace.getLeaf(true);

		await (leaf as any).openFile(abs, {
			eState: line != null ? { line } : {},
		});

		try {
			const view = (leaf as any).view;
			if (
				view?.editor &&
				typeof view.editor.setCursor === "function" &&
				line != null
			) {
				view.editor.setCursor({ line, ch: 0 });
				if (typeof view.editor.scrollIntoView === "function") {
					view.editor.scrollIntoView(
						{ from: { line, ch: 0 }, to: { line, ch: 0 } },
						true
					);
				}
			} else if (
				typeof view?.setEphemeralState === "function" &&
				line != null
			) {
				view.setEphemeralState({ line });
			}
		} catch {
			/* ignore */
		}

		if (line == null && (task as any).blockId) {
			const blockId = (task as any).blockId;
			try {
				(app.workspace as any).openLinkText(
					`${filePath}#^${blockId}`,
					"",
					true
				);
			} catch {
				/* ignore */
			}
		}
	} catch {
		/* ignore */
	}
}

/**
 * Attach a long-press handler to the task's LI to open source in new tab.
 * Ignores interactive targets (checkboxes, buttons, links).
 */
function attachOpenOnLongPress(
	liEl: HTMLElement,
	task: TaskItem,
	app: App
): void {
	if ((liEl as any).__agileOpenAttached) return;

	const LONG_PRESS_MS = 500;
	let pressTimer: number | null = null;

	const clearTimer = () => {
		if (pressTimer !== null) {
			window.clearTimeout(pressTimer);
			pressTimer = null;
		}
	};

	const isInteractiveTarget = (el: HTMLElement | null): boolean => {
		if (!el) return false;
		if (el.closest("input, button, a, .agile-snooze-btn")) return true;
		if (el.closest("label")) return true;
		return false;
	};

	const onPressStart = (ev: Event) => {
		const target = ev.target as HTMLElement | null;
		if (isInteractiveTarget(target)) return;
		clearTimer();
		pressTimer = window.setTimeout(async () => {
			await openTaskInNewTab(app, task);
			clearTimer();
		}, LONG_PRESS_MS);
	};

	const onPressEnd = () => {
		clearTimer();
	};

	liEl.addEventListener("mousedown", onPressStart);
	liEl.addEventListener("mouseup", onPressEnd);
	liEl.addEventListener("mouseleave", onPressEnd);

	liEl.addEventListener("touchstart", onPressStart, { passive: true } as any);
	liEl.addEventListener("touchend", onPressEnd);
	liEl.addEventListener("touchcancel", onPressEnd);

	(liEl as any).__agileOpenAttached = true;
}

/**
 * Render a tree of tasks into the given container.
 */
export function renderTaskTree(
	tasks: TaskItem[],
	container: HTMLElement,
	app: App,
	depth: number,
	isRoot: boolean,
	sectionType: string,
	selectedAlias: string | null
) {
	ensureAssignmentEventListener(app);
	if (tasks.length === 0) return;

	const normalizedSection = normalizeSection(sectionType);
	const taskList = container.createEl("ul", {
		cls: "agile-dashboard contains-task-list",
	});
	taskList.setAttribute("data-section", normalizedSection);

	tasks.forEach((task) => {
		if (
			!task.text?.trim() &&
			!task.visual?.trim() &&
			(!task.children || task.children.length === 0)
		)
			return;

		const tempEl = document.createElement("div");
		const renderComponent = new Component();
		MarkdownRenderer.renderMarkdown(
			(task.visual || task.text || "").trim(),
			tempEl,
			task.link?.path || "",
			renderComponent
		);
		renderComponent.load();

		const firstEl = tempEl.firstElementChild as HTMLElement | null;
		let taskItemEl: HTMLElement;

		if (firstEl?.tagName.toLowerCase() === "ul") {
			if (
				firstEl.children.length === 1 &&
				(
					firstEl.firstElementChild as HTMLElement | null
				)?.tagName.toLowerCase() === "li"
			) {
				taskItemEl = firstEl.firstElementChild as HTMLElement;
				taskList.appendChild(taskItemEl);
			} else {
				taskItemEl = taskList.createEl("li", { cls: "task-list-item" });
				while (tempEl.firstChild) {
					taskItemEl.appendChild(tempEl.firstChild);
				}
			}
		} else {
			taskItemEl = taskList.createEl("li", { cls: "task-list-item" });
			while (tempEl.firstChild) {
				taskItemEl.appendChild(tempEl.firstChild);
			}
		}

		// Stamp the section on each LI so localized refreshes can reliably read it
		taskItemEl.setAttribute("data-section", normalizedSection);

		if (task.annotated) {
			taskItemEl.addClass("annotated-task");
		}

		if (task._uniqueId) {
			taskItemEl.setAttribute("data-task-uid", task._uniqueId);
		}
		const filePath = task.link?.path || "";
		if (filePath) {
			taskItemEl.setAttribute("data-file-path", filePath);
		}
		const line = getTaskLine(task);
		if (line != null) {
			taskItemEl.setAttribute("data-line", String(line));
		}

		try {
			annotateAssigneeMarks(taskItemEl, task._uniqueId || "", filePath);
		} catch {
			/* ignore */
		}

		try {
			appendSnoozeButtonIfEligible(
				task,
				taskItemEl,
				normalizedSection,
				app,
				selectedAlias
			);
			appendSnoozeAllSubtasksButtonIfEligible(
				task,
				taskItemEl,
				normalizedSection,
				app,
				selectedAlias
			);
		} catch {
			/* ignore */
		}

		try {
			attachOpenOnLongPress(taskItemEl, task, app);
		} catch {
			/* ignore */
		}

		const checkbox = taskItemEl.querySelector(
			'input[type="checkbox"]'
		) as HTMLInputElement | null;

		if (checkbox) {
			const interactive = shouldEnableCheckbox(
				sectionType,
				depth,
				task,
				isRoot
			);
			if (!interactive) {
				checkbox.disabled = true;
				checkbox.tabIndex = -1;
				checkbox.setAttribute("aria-disabled", "true");
				(checkbox as HTMLElement).style.pointerEvents = "none";
			} else {
				// Wire dashboard checkbox using the sequencer-provided adapter (short vs long-press)
				const resolvedFilePath =
					task.link?.path || (task._uniqueId?.split(":")[0] ?? "");
				const line0 =
					line != null
						? line
						: (() => {
								const s =
									taskItemEl.getAttribute("data-line") || "";
								return /^\d+$/.test(s) ? parseInt(s, 10) : 0;
						  })();

				attachCustomCheckboxStatusHandlers({
					checkboxEl: checkbox,
					app,
					task: {
						filePath: resolvedFilePath,
						line0,
						status: (task as any)?.status ?? " ",
					},
					onStatusApplied: (to: StatusChar) => {
						// Update in-memory for downstream code relying on task.status
						(task as any).status = to;
						if (to === "/") {
							rerenderTaskInline(
								task,
								taskItemEl,
								app,
								sectionType,
								to,
								isRoot,
								depth,
								selectedAlias
							);
						} else if (to === "x" || to === "-") {
							try {
								hideTaskAndCollapseAncestors(taskItemEl);
							} catch {
								/* ignore */
							}
						}
					},
				});
			}
		}

		if (task.children && task.children.length > 0) {
			renderTaskTree(
				task.children,
				taskItemEl,
				app,
				depth + 1,
				false,
				normalizedSection,
				selectedAlias
			);
		}
	});
}

function rerenderTaskInline(
	task: TaskItem,
	liEl: HTMLElement,
	app: App,
	sectionType: string,
	newStatus: string,
	isRoot: boolean,
	depth: number,
	selectedAlias: string | null
): void {
	try {
		const normalizedSection = normalizeSection(sectionType);

		liEl.setAttribute("data-section", normalizedSection);

		const childLists = Array.from(
			liEl.querySelectorAll(":scope > ul")
		) as HTMLElement[];

		let lineMd = (task.visual || task.text || "").trim();

		if (/^\s*[-*]\s*\[\s*.\s*\]/.test(lineMd)) {
			lineMd = lineMd.replace(
				/^(\s*[-*]\s*\[\s*)(.)(\s*\])/,
				`$1${newStatus}$3`
			);
		} else {
			lineMd = `- [${newStatus}] ${lineMd}`;
		}

		if (newStatus === "/") {
			lineMd = lineMd
				.replace(/\s*(✅|❌)\s+\d{4}-\d{2}-\d{2}\b/g, "")
				.trimEnd();
		}

		liEl.innerHTML = "";

		const tempEl = document.createElement("div");
		const renderComponent = new Component();
		MarkdownRenderer.renderMarkdown(
			lineMd,
			tempEl,
			task.link?.path || "",
			renderComponent
		);
		renderComponent.load();

		const firstEl = tempEl.firstElementChild as HTMLElement | null;
		if (
			firstEl?.tagName.toLowerCase() === "ul" &&
			firstEl.children.length === 1 &&
			(
				firstEl.firstElementChild as HTMLElement | null
			)?.tagName.toLowerCase() === "li"
		) {
			const sourceLi = firstEl.firstElementChild as HTMLElement;
			const hadAnnotated = liEl.classList.contains("annotated-task");

			const dataTask = sourceLi.getAttribute("data-task");
			if (dataTask !== null) liEl.setAttribute("data-task", dataTask);
			else liEl.removeAttribute("data-task");

			const role = sourceLi.getAttribute("role");
			if (role !== null) liEl.setAttribute("role", role);
			else liEl.removeAttribute("role");

			const ariaChecked = sourceLi.getAttribute("aria-checked");
			if (ariaChecked !== null)
				liEl.setAttribute("aria-checked", ariaChecked);
			else liEl.removeAttribute("aria-checked");

			liEl.className = sourceLi.className;
			if (hadAnnotated) liEl.classList.add("annotated-task");

			while (sourceLi.firstChild) {
				liEl.appendChild(sourceLi.firstChild);
			}
		} else {
			while (tempEl.firstChild) {
				liEl.appendChild(tempEl.firstChild);
			}
			liEl.classList.add("task-list-item");
			if (newStatus === "x") liEl.classList.add("is-checked");
			else liEl.classList.remove("is-checked");
			liEl.setAttribute("data-task", newStatus);
		}

		const inputEl = liEl.querySelector(
			'input[type="checkbox"]'
		) as HTMLInputElement | null;
		if (inputEl) {
			inputEl.setAttribute("data-task", newStatus);
		}

		childLists.forEach((ul) => liEl.appendChild(ul));

		try {
			appendSnoozeButtonIfEligible(
				task,
				liEl,
				normalizedSection,
				app,
				selectedAlias
			);
			appendSnoozeAllSubtasksButtonIfEligible(
				task,
				liEl,
				normalizedSection,
				app,
				selectedAlias
			);
		} catch {
			/* ignore */
		}

		try {
			attachOpenOnLongPress(liEl, task, app);
		} catch {
			/* ignore */
		}

		const checkbox = liEl.querySelector(
			'input[type="checkbox"]'
		) as HTMLInputElement | null;

		if (checkbox) {
			const interactive = shouldEnableCheckbox(
				sectionType,
				depth,
				task,
				isRoot
			);
			if (!interactive) {
				checkbox.disabled = true;
				checkbox.tabIndex = -1;
				checkbox.setAttribute("aria-disabled", "true");
				(checkbox as HTMLElement).style.pointerEvents = "none";
			} else {
				const resolvedFilePath =
					task.link?.path || (task._uniqueId?.split(":")[0] ?? "");
				const lineAttr = liEl.getAttribute("data-line") || "";
				const line0 = /^\d+$/.test(lineAttr)
					? parseInt(lineAttr, 10)
					: getTaskLine(task) ?? 0;

				attachCustomCheckboxStatusHandlers({
					checkboxEl: checkbox,
					app,
					task: {
						filePath: resolvedFilePath,
						line0,
						status: (task as any)?.status ?? newStatus,
					},
					onStatusApplied: (to: StatusChar) => {
						(task as any).status = to;
						if (to === "/") {
							rerenderTaskInline(
								task,
								liEl,
								app,
								sectionType,
								to,
								isRoot,
								depth,
								selectedAlias
							);
						} else if (to === "x" || to === "-") {
							try {
								hideTaskAndCollapseAncestors(liEl);
							} catch {
								/* ignore */
							}
						}
					},
				});
			}
		}
	} catch {
		// no-op
	}
}

./src/features/agile-dashboard-view/ui/components/ui-policy.ts
/**
 * UI policy primitives for Agile Dashboard sections.
 * Centralizes shared section normalization logic and section typing.
 */

export type TaskSection =
	| "objectives"
	| "objectives-linked"
	| "responsibilities"
	| "priorities"
	| "initiatives"
	| "epics"
	| "stories"
	| "tasks";

export interface TaskUIPolicy {
	section: TaskSection;
}

/**
 * Normalize a free-form section type string into a TaskSection value.
 * Unknown values default to "tasks".
 */
export function normalizeSection(sectionType: string): TaskSection {
	const s = (sectionType || "").toLowerCase();
	// Make sure to detect the linked-objects variant before the general case
	if (s.includes("objectives-linked")) return "objectives-linked";
	if (s.includes("objective")) return "objectives";
	if (s.includes("responsibil")) return "responsibilities";
	if (s.includes("priorit")) return "priorities";
	if (s.includes("initiative")) return "initiatives";
	if (s.includes("epic")) return "epics";
	if (s.includes("story")) return "stories";
	return "tasks";
}

./src/features/agile-dashboard-view/ui/handlers/assignment-handler.ts
/**
 * Dashboard-level click delegation for assignment template wrappers.
 * Opens the headless reassignment menu where users click the assignee chip in the dashboard.
 *
 * Feature served: Reassignment UX inside the rendered dashboard without navigating to source.
 */

import type { App } from "obsidian";
import type { OrgStructurePort } from "@features/org-structure";
import { openAssignmentMenuAt } from "@features/task-assignment/ui/reassignment-menu";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

export interface AssignmentHandlerOptions {
	app: App;
	orgStructurePort?: OrgStructurePort;
	viewContainer: HTMLElement; // the content area (this.containerEl.children[1])
	registerDomEvent: RegisterDomEvent; // ItemView.registerDomEvent binder for cleanup
}

export function attachDashboardAssignmentHandler(
	opts: AssignmentHandlerOptions
): void {
	const { app, orgStructurePort, viewContainer, registerDomEvent } = opts;
	if (!orgStructurePort) return;

	const handleOpenMenu = (evt: MouseEvent) => {
		try {
			const tgt = evt.target as HTMLElement | null;
			if (!tgt) return;

			// Intercept clicks on the rendered assignee wrapper
			const span = tgt.closest(
				'span[data-template-key="members.assignee"]'
			) as HTMLElement | null;
			if (!span) return;

			// Prevent default navigation/handlers early
			evt.preventDefault();
			evt.stopPropagation();
			// @ts-ignore
			(evt as any).stopImmediatePropagation?.();

			const templateKey = span.getAttribute("data-template-key") ?? "";
			if (templateKey !== "members.assignee") return;

			const instanceId = span.getAttribute("data-template-wrapper") ?? "";
			// AssignType defaults to "assignee" if missing or unknown
			const assignTypeAttr = (
				span.getAttribute("data-assign-type") || ""
			).toLowerCase();
			const assignType: "assignee" | "delegate" =
				assignTypeAttr === "delegate" ? "delegate" : "assignee";

			const currentState = (
				(
					span.getAttribute("data-assignment-state") || ""
				).toLowerCase() === "inactive"
					? "inactive"
					: "active"
			) as "active" | "inactive";

			const currentSlug = (
				span.getAttribute("data-member-slug") || ""
			).trim();

			// Map to task LI and resolve file path + optional hints
			const li =
				span.closest("li[data-file-path]") ||
				span.closest("[data-file-path]"); // fallback if structure changes
			const liEl = li as HTMLElement | null;
			const filePath = liEl?.getAttribute("data-file-path") || "";
			if (!filePath) return;

			const parentUid = liEl?.getAttribute("data-task-uid") || null;
			const lineHintStr = liEl?.getAttribute("data-line") || "";
			const lineHint0 =
				lineHintStr && /^\d+$/.test(lineHintStr)
					? parseInt(lineHintStr, 10)
					: null;

			openAssignmentMenuAt({
				mode: "headless",
				app,
				plugin: null,
				ports: { orgStructure: orgStructurePort },
				at: { x: evt.clientX, y: evt.clientY },
				filePath,
				instanceId, // empty string is ok; underlying code will fall back via type/slug/line
				assignType,
				currentState,
				currentSlug,
				parentUid,
				lineHint0,
			});
		} catch {
			/* ignore */
		}
	};

	// Use capture to intercept before Obsidian's default link behaviors (matches templating handler)
	registerDomEvent(viewContainer, "click", handleOpenMenu, { capture: true });

	// Optional: allow right-click to open the reassignment menu as well
	registerDomEvent(
		viewContainer,
		"contextmenu",
		(evt: MouseEvent) => {
			const tgt = evt.target as HTMLElement | null;
			const span = tgt?.closest(
				'span[data-template-key="members.assignee"]'
			) as HTMLElement | null;
			if (!span) return;
			handleOpenMenu(evt);
		},
		{ capture: true }
	);
}

./src/features/agile-dashboard-view/ui/handlers/event-wiring.ts
import { TFile, type App, type TAbstractFile } from "obsidian";
import type { TaskIndexService } from "@features/task-index";
import { eventBus } from "../../app/event-bus";
import {
	refreshForFile,
	refreshTaskTreeByUid,
} from "../../app/refresh-service";

type RegisterFn = (fn: () => void) => void;
type RegisterEventFn = (evt: any) => void;

export interface WiringOptions {
	app: App;
	taskIndexService: TaskIndexService;
	viewRoot: HTMLElement; // containerEl.children[1]
	getSelectedAlias: () => string | null;
	updateView: () => Promise<void>;
	suppressedFiles: Set<string>;
	register: RegisterFn;
	registerEvent: RegisterEventFn;
}

export function wireDashboardEvents(opts: WiringOptions) {
	const {
		app,
		taskIndexService,
		viewRoot,
		getSelectedAlias,
		updateView,
		suppressedFiles,
		register,
		registerEvent,
	} = opts;

	// Prepare optimistic update suppression
	register(() =>
		eventBus.on("agile:prepare-optimistic-file-change", ({ filePath }) => {
			if (filePath) suppressedFiles.add(filePath);
		})
	);

	const handleAssignmentRefresh = async (filePath?: string) => {
		try {
			if (filePath) {
				suppressedFiles.add(filePath);
				const af = app.vault.getAbstractFileByPath(filePath);
				if (af instanceof TFile) {
					await taskIndexService.updateFile(af);
				}
			}
		} catch {
			/* ignore */
		}
		await updateView();
	};

	register(() =>
		eventBus.on("agile:assignee-changed", async ({ filePath }) => {
			await handleAssignmentRefresh(filePath);
		})
	);

	register(() =>
		eventBus.on("agile:assignment-changed", async ({ filePath }) => {
			await handleAssignmentRefresh(filePath);
		})
	);

	// Snooze → localized subtree refresh (if visible)
	register(() =>
		eventBus.on("agile:task-snoozed", async ({ uid, filePath }) => {
			try {
				if (!uid) return;

				const contentRoot = viewRoot.querySelector(
					".content-container"
				) as HTMLElement | null;

				let targetLi: HTMLElement | null = null;
				if (contentRoot) {
					const allLis = Array.from(
						contentRoot.querySelectorAll("li[data-task-uid]")
					) as HTMLElement[];
					targetLi =
						allLis.find(
							(el) =>
								(el.getAttribute("data-task-uid") || "") === uid
						) || null;
				}

				const isHidden =
					!targetLi ||
					targetLi.style.display === "none" ||
					targetLi.getAttribute("aria-hidden") === "true" ||
					(() => {
						try {
							const cs = getComputedStyle(targetLi!);
							return (
								cs.display === "none" ||
								cs.visibility === "hidden"
							);
						} catch {
							return false;
						}
					})();

				if (isHidden) return;

				try {
					if (filePath) {
						suppressedFiles.add(filePath);
						await refreshForFile(app, taskIndexService, filePath);
					}
				} catch {
					/* ignore */
				}

				await refreshTaskTreeByUid(
					app,
					taskIndexService,
					viewRoot,
					uid,
					getSelectedAlias()
				);
			} catch {
				/* ignore */
			}
		})
	);

	// Vault events
	registerEvent(
		app.vault.on("modify", async (file: TFile) => {
			if (file.extension !== "md") return;
			await taskIndexService.updateFile(file);
			if (suppressedFiles.has(file.path)) {
				suppressedFiles.delete(file.path);
				return;
			}
			void updateView();
		})
	);

	registerEvent(
		app.vault.on("create", async (file: TAbstractFile) => {
			if (file instanceof TFile && file.extension === "md") {
				await taskIndexService.updateFile(file);
				void updateView();
			}
		})
	);

	registerEvent(
		app.vault.on("delete", (file: TAbstractFile) => {
			if (file instanceof TFile && file.extension === "md") {
				taskIndexService.removeFile(file.path);
				void updateView();
			}
		})
	);

	registerEvent(
		app.vault.on("rename", async (file: TAbstractFile, oldPath: string) => {
			if (file instanceof TFile && file.extension === "md") {
				taskIndexService.renameFile(oldPath, file.path);
				void updateView();
			}
		})
	);
}

./src/features/agile-dashboard-view/ui/handlers/templating-handler.ts
/**
 * Adapter: delegates templating param editing handler to the refactored, wiring-agnostic
 * templating-params-editor module. Wires in the Agile Dashboard event bus and
 * the required ports (templating, vault, refresh, notices), with type adapters.
 *
 */

import type { App } from "obsidian";
import {
	attachDashboardTemplatingHandler as attachGenericTemplatingHandler,
	type TemplatingPorts,
	type NoticePort,
	type TemplateParams, // Editor params type
	type TemplateDef as EditorTemplateDef, // Editor template def type
} from "@features/templating-params-editor";
import type {
	ParamsSchema as EditorParamsSchema, // Editor schema type
} from "@features/templating-params-editor/domain/types";

import { createPathFileRepository } from "@platform/obsidian";
import {
	prefillTemplateParams as realPrefillTemplateParams,
	renderTemplateOnly as realRenderTemplateOnly,
	findTemplateById as realFindTemplateById,
} from "@features/templating-engine/app/templating-service";
import { showSchemaModal as realShowSchemaModal } from "@features/templating-params-editor";
import { showJsonModal as realShowJsonModal } from "@features/templating-params-editor";

// Templating module types (to adapt from/to)
import type {
	TemplateDefinition as TmplTemplateDef,
	ParamsSchema as TmplParamsSchema,
	ParamsSchemaField as TmplSchemaField,
	ParamInputType as TmplParamInputType,
} from "@features/templating-engine/domain/types";

import { eventBus } from "../../app/event-bus";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

export interface TemplatingHandlerOptions {
	app: App;
	viewContainer: HTMLElement;
	registerDomEvent: RegisterDomEvent;

	// Dashboard refresh hook
	refreshForFile: (filePath?: string | null) => Promise<void>;

	// Optional notices adapter; if omitted, the generic handler will default to Obsidian Notice
	notices?: NoticePort;

	// If true (default), allow the generic handler to use Obsidian Notice as fallback
	useObsidianNotice?: boolean;
}

/**
 * Map templating module's ParamInputType to the editor's simplified type.
 * Unknowns map to "any".
 */
function mapParamInputTypeToEditor(
	t?: TmplParamInputType
): "string" | "number" | "boolean" | "any" | undefined {
	if (!t) return undefined;
	const v = String(t).toLowerCase();
	if (v.includes("number")) return "number";
	if (v.includes("bool") || v.includes("toggle") || v.includes("check"))
		return "boolean";
	if (
		v.includes("text") ||
		v.includes("string") ||
		v === "input" ||
		v.includes("area")
	)
		return "string";
	return "any";
}

/**
 * Adapt a templating module schema to the editor schema type.
 */
function adaptSchemaToEditor(
	schema: TmplParamsSchema | undefined
): EditorParamsSchema | undefined {
	if (!schema || !Array.isArray(schema.fields)) return undefined;
	const fields: EditorParamsSchema["fields"] = [];
	for (const f of schema.fields) {
		fields.push({
			name: f.name,
			required: f.required,
			defaultValue:
				typeof f.defaultValue === "string"
					? f.defaultValue
					: (f.defaultValue as unknown as string | undefined),
			type: mapParamInputTypeToEditor(f.type),
		});
	}
	return { fields };
}

/**
 * Adapt the editor schema to the templating module schema type.
 * We intentionally omit "type" to avoid enum coupling; the templating UI can infer/default.
 */
function adaptSchemaToTemplating(schema: EditorParamsSchema): TmplParamsSchema {
	const fields: TmplSchemaField[] = [];
	for (const f of schema.fields) {
		const out: TmplSchemaField = {
			name: f.name,
			required: f.required,
			defaultValue: f.defaultValue,
			// Note: omit "type" to avoid enum mismatches
		} as TmplSchemaField;
		fields.push(out);
	}
	return { fields };
}

/**
 * Adapt templating module's TemplateDefinition to the editor's TemplateDef.
 */
function adaptTemplateDefToEditor(
	def: TmplTemplateDef | undefined
): EditorTemplateDef | undefined {
	if (!def) return undefined;
	return {
		id: def.id,
		hasParams: !!def.hasParams, // ensure boolean
		hiddenFromDynamicCommands: def.hiddenFromDynamicCommands,
		paramsSchema: adaptSchemaToEditor(def.paramsSchema),
	};
}

/**
 * Attach the dashboard templating handler using the refactored feature.
 * This implementation:
 * - Uses platform/obsidian's createPathFileRepository for VaultPort compatibility
 * - Drops legacy infra adapters
 * - Lets the feature's UI handler default to Obsidian Notice when no notices are provided
 */
export function attachDashboardTemplatingHandler(
	opts: TemplatingHandlerOptions
): void {
	const {
		app,
		viewContainer,
		registerDomEvent,
		refreshForFile,
		notices,
		useObsidianNotice = true,
	} = opts;

	// Wire templating ports by wrapping the existing templating service and modal UIs.
	const templating: TemplatingPorts = {
		findTemplateById: (id) =>
			adaptTemplateDefToEditor(realFindTemplateById(id)),
		prefillTemplateParams: (templateId, wrapperEl) =>
			realPrefillTemplateParams(templateId, wrapperEl) as TemplateParams,
		renderTemplateOnly: (templateId, params) =>
			realRenderTemplateOnly(templateId, params),
		showSchemaModal: async (templateId, schema, isEdit) => {
			const schemaForTemplating: TmplParamsSchema =
				adaptSchemaToTemplating(schema);
			const result = await realShowSchemaModal(
				app,
				templateId,
				schemaForTemplating,
				isEdit
			);
			return result as TemplateParams | undefined;
		},
		showJsonModal: (templateId, initialJson) =>
			realShowJsonModal(app, templateId, initialJson) as Promise<
				TemplateParams | undefined
			>,
	};

	// Use platform/obsidian file repository as VaultPort.
	// Note: VaultPort.fileExists is optional; feature code will fall back to read-try/catch if absent.
	const repo = createPathFileRepository(app);
	const vault = {
		readFile: repo.readFile,
		writeFile: repo.writeFile,
		// no fileExists; optional by design
	};

	attachGenericTemplatingHandler({
		app,
		viewContainer,
		registerDomEvent,
		deps: {
			templating,
			vault,
			refresh: { refreshForFile },
			notices, // allow undefined; handler will default to Obsidian Notice if allowed
			eventBus,
		},
		useObsidianNotice,
	});
}

./src/features/agile-dashboard-view/ui/utils/filters.ts
/**
 * Shared filtering utilities for Agile Dashboard sections.
 */

import type { TaskItem, TaskParams } from "@features/task-index";
import {
	isCancelled,
	isCompleted,
	isInProgress,
	isSnoozed,
} from "@features/task-filter";

/**
 * Return true when a task should be visible based on current status toggles and snooze.
 *
 * - inProgress => include active/in-progress tasks (but not snoozed)
 * - completed  => include completed items
 * - sleeping   => include snoozed items (for the selected alias context)
 * - cancelled  => include cancelled items
 */
export function isShownByParams(
	task: TaskItem,
	taskMap: Map<string, TaskItem>,
	selectedAlias: string | null,
	params: TaskParams
): boolean {
	const { inProgress, completed, sleeping, cancelled } = params;
	const snoozedForAlias = isSnoozed(task, taskMap, selectedAlias);

	const includeInProgress =
		inProgress &&
		isInProgress(task, taskMap, selectedAlias) &&
		!snoozedForAlias;
	const includeCompleted = completed && isCompleted(task);
	const includeSleeping = sleeping && snoozedForAlias;
	const includeCancelled = cancelled && isCancelled(task);

	return (
		includeInProgress ||
		includeCompleted ||
		includeSleeping ||
		includeCancelled
	);
}

./src/features/agile-dashboard-view/ui/utils/scroll.ts
export function captureScroll(container: HTMLElement): {
	outer: number;
	inner: number;
} {
	const content = container.querySelector(
		".content-container"
	) as HTMLElement | null;
	return { outer: container.scrollTop, inner: content?.scrollTop ?? 0 };
}

export function restoreScroll(
	container: HTMLElement,
	state: { outer: number; inner: number }
) {
	const content = container.querySelector(
		".content-container"
	) as HTMLElement | null;
	container.scrollTop = state.outer ?? 0;
	if (content) content.scrollTop = state.inner ?? 0;
}

./src/features/agile-dashboard-view/ui/views/agile-dashboard-view.ts
import { ItemView, WorkspaceLeaf } from "obsidian";
import manifest from "manifest.json";

import type { TaskIndexService } from "@features/task-index";
import type { SettingsService } from "@settings";
import type { OrgStructurePort } from "@features/org-structure";

import { DashboardController } from "../../app/controller";

export const VIEW_TYPE_AGILE_DASHBOARD = "agile-dashboard-view";

export type AgileDashboardViewPorts = {
	taskIndex?: TaskIndexService;
	settings: SettingsService;
	orgStructure?: OrgStructurePort;
	manifestId?: string;
};

export class AgileDashboardView extends ItemView {
	private taskIndexService: TaskIndexService;
	private settingsService: SettingsService;
	private orgStructurePort?: OrgStructurePort;
	private controller!: DashboardController;
	private storageKey: string;

	constructor(leaf: WorkspaceLeaf, ports: AgileDashboardViewPorts) {
		super(leaf);
		this.settingsService = ports.settings;
		this.orgStructurePort = ports.orgStructure;

		const svc = ports.taskIndex;
		if (!svc) {
			console.warn(
				"[AgileDashboardView] TaskIndexService not found in ports."
			);
			this.taskIndexService = {
				buildAll: async () => {},
				updateFile: async () => {},
				removeFile: () => {},
				renameFile: () => {},
				getSnapshot: () => ({} as any),
				getAllTasks: () => [],
				getByFile: () => undefined,
				getById: () => undefined,
				getItemAtCursor: () => undefined,
			} as unknown as TaskIndexService;
		} else {
			this.taskIndexService = svc;
		}

		const mid = (ports.manifestId || "").trim() || "agile-default";
		this.storageKey = `agile:selected-team-slugs:${mid}`;
	}

	getViewType() {
		return VIEW_TYPE_AGILE_DASHBOARD;
	}

	getDisplayText() {
		return "Agile Dashboard";
	}

	getIcon() {
		return "calendar-clock";
	}

	async onOpen() {
		this.controller = new DashboardController({
			app: this.app,
			view: this,
			taskIndexService: this.taskIndexService,
			settingsService: this.settingsService,
			orgStructurePort: this.orgStructurePort,
			manifestVersion: manifest.version,
			storageKey: this.storageKey,
			register: this.register.bind(this),
			registerEvent: this.registerEvent.bind(this),
			registerDomEvent: this.registerDomEvent.bind(this),
		});

		this.controller.mount();
	}

	async onClose() {
		if (this.controller) this.controller.unmount();
	}
}

./src/features/agile-dashboard-view/ui/views/project-view.ts
import type { App } from "obsidian";
import type {
	TaskItem,
	TaskIndexService,
	TaskParams,
} from "@features/task-index";
import type { SettingsService } from "@settings";
import { processAndRenderObjectives } from "../components/objectives";
import { processAndRenderArtifacts } from "../components/artifacts";
import { processAndRenderInitiatives } from "../components/initiatives";
import { processAndRenderResponsibilities } from "../components/responsibilities";
import { processAndRenderPriorities } from "../components/priorities";
import { TeamSelection } from "../../domain/team-selection";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

export interface ProjectViewOptions {
	app: App;
	container: HTMLElement;
	taskIndexService: TaskIndexService;
	settingsService: SettingsService;
	teamSelection: TeamSelection;
	statusActive: boolean;
	selectedAlias: string | null;
	registerDomEvent: RegisterDomEvent;
}

export async function renderProjectView(opts: ProjectViewOptions) {
	const {
		app,
		container,
		taskIndexService,
		settingsService,
		teamSelection,
		statusActive,
		selectedAlias,
		registerDomEvent,
	} = opts;

	if (
		!teamSelection.getImplicitAllSelected() &&
		teamSelection.getSelectedTeamSlugs().size === 0
	) {
		const msg = container.createEl("div", {
			attr: {
				style: "display:flex; align-items:center; justify-content:center; min-height: 240px; text-align:center; opacity:0.8;",
			},
		});
		msg.createEl("div", {
			text: "No organizations/teams selected. Select a team or organization to view the dashboard",
		});
		return;
	}

	let currentTasks: TaskItem[] = taskIndexService.getAllTasks();

	currentTasks = currentTasks.filter((t) =>
		teamSelection.isTaskAllowedByTeam(
			t as unknown as TaskItem,
			selectedAlias
		)
	);

	const taskMap = new Map<string, TaskItem>();
	const childrenMap = new Map<string, TaskItem[]>();
	currentTasks.forEach((t) => {
		if (t._uniqueId) {
			taskMap.set(t._uniqueId, t as unknown as TaskItem);
			childrenMap.set(t._uniqueId, []);
		}
	});
	currentTasks.forEach((t) => {
		const tt = t as unknown as TaskItem;
		if (tt._parentId && childrenMap.has(tt._parentId)) {
			childrenMap.get(tt._parentId)!.push(tt);
		}
	});

	const taskParams: TaskParams = {
		inProgress: true,
		completed: false,
		sleeping: false,
		cancelled: false,
	};
	const settings = settingsService.getRaw();

	if (settings.showObjectives) {
		processAndRenderObjectives(
			container,
			currentTasks as unknown as TaskItem[],
			statusActive,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			registerDomEvent
		);
	}
	if (settings.showResponsibilities) {
		processAndRenderResponsibilities(
			container,
			currentTasks as unknown as TaskItem[],
			statusActive,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			registerDomEvent
		);
	}
	processAndRenderArtifacts(
		container,
		currentTasks as unknown as TaskItem[],
		statusActive,
		selectedAlias,
		app,
		taskMap,
		childrenMap,
		taskParams,
		settings,
		registerDomEvent
	);
	if (settings.showInitiatives) {
		processAndRenderInitiatives(
			container,
			currentTasks as unknown as TaskItem[],
			statusActive,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			registerDomEvent
		);
	}
	if (settings.showPriorities) {
		processAndRenderPriorities(
			container,
			currentTasks as unknown as TaskItem[],
			statusActive,
			selectedAlias,
			app,
			taskMap,
			childrenMap,
			taskParams,
			registerDomEvent
		);
	}
}

./src/features/agile-dashboard-view/ui/views/task-index-accesor.ts
import type AgileObsidianPlugin from "src/main";
import type { TaskIndexService } from "@features/task-index/app/task-index-service";

export function getTaskIndexServiceFromContainer(
	plugin: AgileObsidianPlugin
): TaskIndexService | undefined {
	const container: any = plugin.container;
	return container?.taskIndexService as TaskIndexService | undefined;
}

./src/features/agile-dashboard-view/ui/views/teams-popup.ts
import type {
	OrgStructurePort,
	OrganizationNode,
	TeamNode,
} from "@features/org-structure";

/**
 * Context/state/accessors needed to render the Teams popup.
 */
export interface TeamsPopupContext {
	root: HTMLDivElement;
	orgStructurePort?: OrgStructurePort;

	// Selection state owned by the view
	selectedTeamSlugs: Set<string>;
	implicitAllSelected: boolean;

	// State mutators
	setImplicitAllSelected(val: boolean): void;
	addSelectedSlugs(slugs: string[]): void;
	removeSelectedSlugs(slugs: string[]): void;

	// Called after any selection changes
	onSelectionChanged(): void;

	// Return allowed slugs for current user, or null when unknown (no filtering)
	getAllowedTeamSlugsForSelectedUser(): Set<string> | null;
}

/**
 * Render the entire content of the Teams popup into root.
 */
export function renderTeamsPopupContent(ctx: TeamsPopupContext) {
	const root = ctx.root;
	root.innerHTML = "";

	const header = root.createEl("div", {
		attr: {
			style: "display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px;",
		},
	});
	header.createEl("strong", { text: "Select Teams" });
	const help = header.createEl("span", {
		text: "Choose organizations/teams to show in the dashboard",
	});
	help.style.opacity = "0.7";
	help.style.fontSize = "12px";

	if (!ctx.orgStructurePort) {
		root.createEl("em", { text: "Organization data unavailable." });
		return;
	}

	const { organizations, teams } = ctx.orgStructurePort.getOrgStructure();

	const allowed = ctx.getAllowedTeamSlugsForSelectedUser(); // null => unknown; do not filter
	const predicate = allowed
		? (slug: string) => allowed.has((slug || "").toLowerCase())
		: (_slug: string) => true;

	const filteredOrgs: OrganizationNode[] = (organizations || []).filter(
		(org) => {
			const slugs = collectOrgTeamSlugs(org);
			return slugs.some((s) => predicate(s));
		}
	);

	const independentsRaw = (teams || []).filter(
		(t) => (t.subteams?.length ?? 0) === 0
	);
	const independents = independentsRaw.filter((t) => {
		const slug = extractPossibleSlug(t);
		return slug && predicate(slug);
	});

	const hasOrgs = filteredOrgs.length > 0;
	const hasIndependents = independents.length > 0;

	if (!hasOrgs && !hasIndependents) {
		root.createEl("em", { text: "No organizations or teams available." });
		return;
	}

	if (hasOrgs) {
		renderAccordion(
			root,
			"Organizations",
			() => {
				const wrapper = document.createElement("div");
				wrapper.style.display = "flex";
				wrapper.style.flexDirection = "column";
				wrapper.style.gap = "6px";

				for (const org of filteredOrgs) {
					const orgEl = renderOrganizationEntryFiltered(
						ctx,
						org,
						predicate
					);
					if (orgEl) wrapper.appendChild(orgEl);
				}
				return wrapper;
			},
			true
		);
	}

	if (hasIndependents) {
		renderAccordion(
			root,
			"Teams",
			() => {
				const wrapper = document.createElement("div");
				wrapper.style.display = "flex";
				wrapper.style.flexDirection = "column";
				wrapper.style.gap = "6px";

				for (const t of independents) {
					const row = document.createElement("div");
					row.style.display = "flex";
					row.style.alignItems = "center";
					row.style.gap = "6px";

					const cb = document.createElement("input");
					cb.type = "checkbox";
					const slug = extractPossibleSlug(t);
					cb.checked = isSlugSelected(ctx, slug);

					cb.addEventListener("change", () => {
						if (!slug) return;
						ctx.setImplicitAllSelected(false);
						if (cb.checked) ctx.addSelectedSlugs([slug]);
						else ctx.removeSelectedSlugs([slug]);
						ctx.onSelectionChanged();
					});

					const label = document.createElement("label");
					const name = extractPossibleName(t);
					label.textContent = `${name} (${
						(t as any).teamSlug || (t as any).slug || ""
					})`;
					label.style.cursor = "pointer";
					label.addEventListener("click", () => cb.click());

					row.appendChild(cb);
					row.appendChild(label);
					wrapper.appendChild(row);
				}

				return wrapper;
			},
			true
		);
	}
}

function renderAccordion(
	parent: HTMLElement,
	title: string,
	contentBuilder: () => HTMLElement,
	defaultOpen = false
) {
	const section = parent.createEl("div", {
		attr: {
			style: "border-top:1px solid var(--background-modifier-border); padding-top:8px; margin-top:8px;",
		},
	});

	const hdr = section.createEl("div", {
		attr: {
			style: "display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none;",
		},
	});
	const chev = hdr.createEl("span", { text: defaultOpen ? "▾" : "▸" });
	hdr.createEl("span", {
		text: title,
		attr: { style: "font-weight:600;" },
	});

	const content = contentBuilder();
	content.style.display = defaultOpen ? "block" : "none";
	section.appendChild(content);

	hdr.addEventListener("click", () => {
		const open = content.style.display !== "none";
		content.style.display = open ? "none" : "block";
		chev.textContent = open ? "▸" : "▾";
	});
}

function renderOrganizationEntryFiltered(
	ctx: TeamsPopupContext,
	org: OrganizationNode,
	isAllowed: (slug: string) => boolean
): HTMLElement | null {
	// Collect only allowed team slugs in this org (so group-level checkbox matches visible subset)
	const allOrgTeamSlugs = collectOrgTeamSlugs(org).filter(isAllowed);
	if (allOrgTeamSlugs.length === 0) {
		return null;
	}

	const container = document.createElement("div");
	container.style.display = "flex";
	container.style.flexDirection = "column";
	container.style.gap = "4px";

	const row = document.createElement("div");
	row.style.display = "flex";
	row.style.alignItems = "center";
	row.style.gap = "6px";

	const cb = document.createElement("input");
	cb.type = "checkbox";

	const state = computeSelectionState(ctx, allOrgTeamSlugs);
	cb.checked = state === "all";
	(cb as any).indeterminate = state === "partial";

	cb.addEventListener("change", () => {
		ctx.setImplicitAllSelected(false);
		if (cb.checked) ctx.addSelectedSlugs(allOrgTeamSlugs);
		else ctx.removeSelectedSlugs(allOrgTeamSlugs);
		ctx.onSelectionChanged();
	});

	const label = document.createElement("label");
	label.textContent = `${(org as any).orgName || (org as any).name || ""} (${
		(org as any).orgSlug || (org as any).slug || ""
	})`;
	label.style.cursor = "pointer";
	label.addEventListener("click", () => cb.click());

	const expandBtn = document.createElement("button");
	expandBtn.type = "button";
	expandBtn.textContent = "▸";
	expandBtn.style.border = "none";
	expandBtn.style.background = "none";
	expandBtn.style.cursor = "pointer";
	expandBtn.style.fontSize = "12px";
	expandBtn.title = "Show teams";

	row.appendChild(cb);
	row.appendChild(label);
	row.appendChild(expandBtn);

	const nested = document.createElement("div");
	nested.style.display = "none";
	nested.style.marginLeft = "18px";
	nested.style.marginTop = "4px";

	expandBtn.addEventListener("click", () => {
		const open = nested.style.display !== "none";
		nested.style.display = open ? "none" : "block";
		expandBtn.textContent = open ? "▸" : "▾";
	});

	for (const team of org.teams || []) {
		const tEl = renderTeamNodeEntryFiltered(ctx, team, 0, isAllowed);
		if (tEl) nested.appendChild(tEl);
	}

	container.appendChild(row);
	container.appendChild(nested);
	return container;
}

function renderTeamNodeEntryFiltered(
	ctx: TeamsPopupContext,
	node: TeamNode,
	level: number,
	isAllowed: (slug: string) => boolean
): HTMLElement | null {
	const hasChildren = (node.subteams?.length ?? 0) > 0;

	const allSlugsHere = collectTeamNodeSlugs(node);
	if (!allSlugsHere.some(isAllowed)) return null;

	const visibleSlugsHere = allSlugsHere.filter(isAllowed);

	const wrapper = document.createElement("div");
	wrapper.style.display = "flex";
	wrapper.style.flexDirection = "column";
	wrapper.style.gap = "4px";

	const row = document.createElement("div");
	row.style.display = "flex";
	row.style.alignItems = "center";
	row.style.gap = "6px";
	row.style.paddingLeft = `${Math.min(24, level * 12)}px`;

	const cb = document.createElement("input");
	cb.type = "checkbox";

	const state = computeSelectionState(ctx, visibleSlugsHere);
	cb.checked = state === "all";
	(cb as any).indeterminate = state === "partial";

	cb.addEventListener("change", () => {
		ctx.setImplicitAllSelected(false);
		if (cb.checked) ctx.addSelectedSlugs(visibleSlugsHere);
		else ctx.removeSelectedSlugs(visibleSlugsHere);
		ctx.onSelectionChanged();
	});

	const label = document.createElement("label");
	label.textContent = `${
		(node as any).teamName || (node as any).name || ""
	} (${(node as any).teamSlug || (node as any).slug || ""})`;
	label.style.cursor = "pointer";
	label.addEventListener("click", () => cb.click());

	row.appendChild(cb);
	row.appendChild(label);

	let nestedChildren: HTMLDivElement | null = null;
	if (hasChildren) {
		const expandBtn = document.createElement("button");
		expandBtn.type = "button";
		expandBtn.textContent = "▸";
		expandBtn.style.border = "none";
		expandBtn.style.background = "none";
		expandBtn.style.cursor = "pointer";
		expandBtn.style.fontSize = "12px";
		expandBtn.title = "Show subteams";
		row.appendChild(expandBtn);

		nestedChildren = document.createElement("div");
		nestedChildren.style.display = "none";
		nestedChildren.style.marginLeft = "18px";
		nestedChildren.style.marginTop = "4px";

		expandBtn.addEventListener("click", () => {
			const open = nestedChildren!.style.display !== "none";
			nestedChildren!.style.display = open ? "none" : "block";
			expandBtn.textContent = open ? "▸" : "▾";
		});
	}

	wrapper.appendChild(row);

	if (hasChildren && nestedChildren) {
		for (const child of node.subteams || []) {
			const childEl = renderTeamNodeEntryFiltered(
				ctx,
				child,
				level + 1,
				isAllowed
			);
			if (childEl) nestedChildren.appendChild(childEl);
		}
		wrapper.appendChild(nestedChildren);
	}

	return wrapper;
}

function isSlugSelected(ctx: TeamsPopupContext, slug: string): boolean {
	if (ctx.implicitAllSelected) return true;
	return ctx.selectedTeamSlugs.has((slug || "").toLowerCase());
}

function computeSelectionState(
	ctx: TeamsPopupContext,
	slugs: string[]
): "all" | "none" | "partial" {
	if (ctx.implicitAllSelected) return "all";
	let selected = 0;
	for (const s of slugs) {
		if (ctx.selectedTeamSlugs.has(s.toLowerCase())) selected++;
	}
	if (selected === 0) return "none";
	if (selected === slugs.length) return "all";
	return "partial";
}

function collectTeamNodeSlugs(node: TeamNode): string[] {
	const slugs: string[] = [];
	const visit = (n: TeamNode) => {
		const s = extractPossibleSlug(n);
		if (s) slugs.push(s);
		for (const c of n.subteams || []) visit(c);
	};
	visit(node);
	return slugs;
}

function collectOrgTeamSlugs(org: OrganizationNode): string[] {
	const slugs: string[] = [];
	for (const t of org.teams || []) {
		slugs.push(...collectTeamNodeSlugs(t));
	}
	return Array.from(new Set(slugs));
}

function extractPossibleSlug(obj: unknown): string {
	if (!obj || typeof obj !== "object") return "";
	const anyObj = obj as Record<string, unknown>;
	const cand =
		anyObj.slug ??
		anyObj.teamSlug ??
		anyObj.id ??
		anyObj.key ??
		anyObj.code;
	return typeof cand === "string"
		? cand.toLowerCase().trim()
		: String(cand || "")
				.toLowerCase()
				.trim();
}

function extractPossibleName(obj: unknown): string {
	if (!obj || typeof obj !== "object") return "";
	const anyObj = obj as Record<string, unknown>;
	const cand =
		anyObj.name ?? anyObj.teamName ?? anyObj.displayName ?? anyObj.title;
	return typeof cand === "string" ? cand : "";
}

./src/features/task-filter/domain/agile-artifact-types.ts
import { TaskItem } from "@features/tasks";
import { getTemplateKeysFromTask } from "@features/templating-engine";
import type { AgileArtifactType } from "./types";

/**
 * Fallback: extract template keys directly from HTML wrappers if present.
 * Looks for data-template-key="...".
 */
function extractTemplateKeysFromText(
	text: string | undefined | null
): string[] {
	if (!text || typeof text !== "string") return [];
	const re = /data-template-key\s*=\s*["']([^"']+)["']/gi;
	const keys: string[] = [];
	for (const m of text.matchAll(re)) {
		if (m[1]) keys.push(m[1]);
	}
	return keys;
}

/**
 * Normalize a template key to a canonical AgileArtifactType by pattern matching.
 * This is resilient to different naming styles (kebab/camel/dotted, v2 suffixes, etc.).
 */
function inferTypeFromKey(key: string): AgileArtifactType | undefined {
	if (!key) return undefined;

	// Lowercase and variants for robust matching
	const k = key.toLowerCase();
	// Flatten out separators to catch things like "agile.user_story" / "agile-userStory" / "agile.userstory"
	const flat = k.replace(/[._-\s]+/g, "");

	// Handle version suffixes like ".v2", "-v3", etc. (non-destructive for other patterns)
	const kNoVer = k.replace(/([._-])v(?:er(?:sion)?)?\d+\b/g, "");
	const flatNoVer = kNoVer.replace(/[._-\s]+/g, "");

	const has = (s: string) =>
		k.includes(s) ||
		flat.includes(s) ||
		kNoVer.includes(s) ||
		flatNoVer.includes(s);

	// Most specific first

	// Learning Initiative
	if (
		has("learninginitiative") ||
		(has("learning") && has("initiative")) ||
		has("personallearninginitiative")
	) {
		return "learning-initiative";
	}

	// Learning Epic
	if (
		has("learningepic") ||
		(has("learning") && has("epic")) ||
		has("personallearningepic")
	) {
		return "learning-epic";
	}

	// Initiative
	if (has("agile.initiative") || has("initiative")) {
		return "initiative";
	}

	// Epic
	if (has("agile.epic") || has("epic")) {
		return "epic";
	}

	// Story / User Story
	if (has("agile.userstory") || has("userstory") || has("user_story")) {
		return "story";
	}
	// Guarded fallback: "story" as a standalone token (avoid matching "history")
	if (/(^|[^a-z])story([^a-z]|$)/.test(k)) {
		return "story";
	}

	// OKR
	if (has("agile.okr") || has("okr")) {
		return "okr";
	}

	// Recurring Responsibility
	if (
		has("agile.recurringres") ||
		has("recurringres") ||
		has("recurring-responsibility") ||
		has("recurringresponsibility")
	) {
		return "recurring-responsibility";
	}

	return undefined;
}

/**
 * Heuristic fallback when templating is missing:
 * If a line has "🔁" plus an assignee wrapper, treat as a recurring responsibility.
 * Conservatively avoid colliding with initiatives/epics/stories.
 */
function heuristicRecurringResponsibility(
	text: string
): AgileArtifactType | undefined {
	if (typeof text !== "string" || text.length === 0) return undefined;
	const hasLoop = text.includes("🔁");
	// New-format assignee wrapper
	const hasAssigneeWrapper =
		/<span\b[^>]*data-template-key\s*=\s*["']members\.assignee["'][^>]*>/i.test(
			text
		);
	if (!hasLoop || !hasAssigneeWrapper) return undefined;

	// Avoid misclassifying common artifact words if present elsewhere
	const lc = text.toLowerCase();
	if (
		/\binitiative\b/.test(lc) ||
		/\bepic\b/.test(lc) ||
		/\buser\s*story\b|\bstory\b/.test(lc)
	) {
		return undefined;
	}
	return "recurring-responsibility";
}

/**
 * Resolve the first matching canonical type from present template keys, if any.
 * If no recognized template is present:
 * - returns "task" for non-open/done/archived items (legacy rule)
 * - returns null for open/done/archived items (preserve prior behavior)
 */
export const getAgileArtifactType = (
	task: TaskItem
): AgileArtifactType | null => {
	const txt = typeof task?.text === "string" ? task.text : "";

	try {
		// Prefer templating helper
		const keysFromHelper =
			(getTemplateKeysFromTask(task) as string[]) ?? [];

		// 1) Try helper-provided keys first
		for (const k of keysFromHelper) {
			const inferred = inferTypeFromKey(k);
			if (inferred) {
				return inferred;
			}
		}

		// 2) If no match yet, scan inline wrappers (helper may miss artifact key)
		if (txt && txt.includes("data-template-key")) {
			const scannedKeys = extractTemplateKeysFromText(txt);
			for (const k of scannedKeys) {
				const inferred = inferTypeFromKey(k);
				if (inferred) {
					return inferred;
				}
			}
		}

		// 2b) Heuristic fallback for recurring-responsibility (template missing)
		const heuristic = heuristicRecurringResponsibility(txt);
		if (heuristic) {
			return heuristic;
		}

		// 3) No template detected -> preserve original rule
		const status = (task as any)?.status;
		return status !== "O" && status !== "d" && status !== "A"
			? "task"
			: null;
	} catch {
		// Safe fallback
		const status = (task as any)?.status;
		return status !== "O" && status !== "d" && status !== "A"
			? "task"
			: null;
	}
};

./src/features/task-filter/domain/task-filters.ts
import { TaskItem } from "@features/tasks";
import { Tokens } from "./types";
import { escapeRegExp } from "@utils";
import {
	DateRe,
	parseYyyyMmDd,
	todayAtMidnight,
} from "@features/task-date-manager";

/**
 * Utility: parse new inline assignee wrappers from a task line.
 * We only need the opening tag's attributes.
 */
type AssigneeSpan = {
	assignType: "assignee" | "delegate" | null;
	assignmentState: "active" | "inactive" | null;
	memberSlug: string | null;
	memberType?: string | null;
};

function getAttr(tag: string, name: string): string | null {
	const re1 = new RegExp(`\\b${name}\\s*=\\s*"([^"]*)"`, "i");
	const m1 = re1.exec(tag);
	if (m1) return m1[1] ?? null;
	const re2 = new RegExp(`\\b${name}\\s*=\\s*'([^']*)'`, "i");
	const m2 = re2.exec(tag);
	return m2 ? m2[1] ?? null : null;
}

function parseAssigneeSpans(text: string | undefined | null): AssigneeSpan[] {
	if (!text || typeof text !== "string") return [];
	const out: AssigneeSpan[] = [];
	const openTagRe =
		/<span\b[^>]*data-template-key\s*=\s*["']members\.assignee["'][^>]*>/gi;
	for (const m of text.matchAll(openTagRe)) {
		const tag = m[0] ?? "";
		const assignTypeRaw = (
			getAttr(tag, "data-assign-type") || ""
		).toLowerCase();
		const assignmentStateRaw = (
			getAttr(tag, "data-assignment-state") || ""
		).toLowerCase();
		const memberSlugRaw = getAttr(tag, "data-member-slug");
		const memberTypeRaw = getAttr(tag, "data-member-type");

		const assignType: "assignee" | "delegate" | null =
			assignTypeRaw === "assignee" || assignTypeRaw === "delegate"
				? (assignTypeRaw as "assignee" | "delegate")
				: null;

		const assignmentState: "active" | "inactive" | null =
			assignmentStateRaw === "active" || assignmentStateRaw === "inactive"
				? (assignmentStateRaw as "active" | "inactive")
				: null;

		out.push({
			assignType,
			assignmentState,
			memberSlug: memberSlugRaw ? memberSlugRaw.trim() : null,
			memberType: memberTypeRaw ? memberTypeRaw.trim() : null,
		});
	}
	return out;
}

/**
 * Checks if a task is completed using the new format only:
 * - ✅ marker, with optional space and optional date:
 *   "✅ 2025-01-31", "✅2025-01-31", or just "✅"
 */
export const isCompleted = (task: TaskItem): boolean => {
	const txt = task?.text ?? "";
	const completedEmoji = escapeRegExp(Tokens.CompletedEmoji);
	const completedWithOptionalDate = new RegExp(
		`${completedEmoji}(?:\\s?${DateRe.source})?`
	);
	return completedWithOptionalDate.test(txt);
};

/**
 * Checks if a task is cancelled using the new format only:
 * - ❌ marker, with optional space and optional date:
 *   "❌ 2025-01-31", "❌2025-01-31", or just "❌"
 */
export const isCancelled = (task: TaskItem): boolean => {
	const txt = task?.text ?? "";
	const cancelledEmoji = escapeRegExp(Tokens.CancelledEmoji);
	const cancelledWithOptionalDate = new RegExp(
		`${cancelledEmoji}(?:\\s?${DateRe.source})?`
	);
	return cancelledWithOptionalDate.test(txt);
};

/**
 * A task is considered "in progress" if it is not completed, not cancelled, and not snoozed.
 * Snoozed tasks are not in progress.
 */
export const isInProgress = (
	task: TaskItem,
	taskMap: Map<string, TaskItem>,
	selectedAlias: string | null
): boolean => {
	return (
		!isCompleted(task) &&
		!isCancelled(task) &&
		!isSnoozed(task, taskMap, selectedAlias)
	);
};

type SnoozeMatch = {
	alias?: string | null;
	date?: string | null;
};

function collectSnoozeMatches(text: string, inherited: boolean): SnoozeMatch[] {
	// Direct snooze: 💤 [hidden-alias]? [date]?
	// Inherited snooze: 💤⬇️ [hidden-alias]? [date]?
	// Hidden alias is inside a span with style="display:none"
	const suffix = inherited
		? `${escapeRegExp(Tokens.SnoozeInheritedMarker)}`
		: `(?!${escapeRegExp(Tokens.SnoozeInheritedMarker)})`;
	const re = new RegExp(
		`${escapeRegExp(
			Tokens.SnoozeEmoji
		)}${suffix}\\s*(?:<span[^>]*style="\\s*display:\\s*none\\s*"[^>]*>([^<]*)<\\/span>)?\\s*(${
			DateRe.source
		})?`,
		"g"
	);
	const matches: SnoozeMatch[] = [];
	for (const m of text.matchAll(re)) {
		const rawAlias = (m[1] ?? null) as string | null;
		matches.push({
			alias: typeof rawAlias === "string" ? rawAlias.trim() : null,
			date: m[2] ?? null,
		});
	}
	return matches;
}

/**
 * Returns true if the task is snoozed either directly or by inheritance from ancestors.
 * New-format only:
 * - Global snooze (no alias) applies to everyone until date (if provided). Without date, indefinite.
 * - Alias-specific snooze applies only to selectedAlias (hidden within a display:none span).
 * - Inheritance is indicated with 💤⬇️ on ancestors; direct snooze uses 💤 without ⬇️.
 * - A snooze with a valid future date snoozes until that date (exclusive). Past or invalid dates do not snooze.
 */
export const isSnoozed = (
	task: TaskItem,
	taskMap: Map<string, TaskItem>,
	selectedAlias: string | null
): boolean => {
	if (!task || typeof task.text !== "string") {
		return false;
	}
	const today = todayAtMidnight();

	const applies = (matches: SnoozeMatch[], allowGlobal: boolean): boolean => {
		// Global snooze (no alias)
		const global = matches.find((m) => !m.alias);
		if (global && allowGlobal) {
			const until = parseYyyyMmDd(global.date ?? undefined);
			if (!global.date) return true;
			if (until && until > today) return true;
		}
		if (selectedAlias) {
			const aliasMatch = matches.find(
				(m) =>
					(m.alias ?? "").trim().toLowerCase() ===
					selectedAlias.toLowerCase()
			);
			if (aliasMatch) {
				const until = parseYyyyMmDd(aliasMatch.date ?? undefined);
				if (!aliasMatch.date) return true;
				if (until && until > today) return true;
			}
		}
		return false;
	};

	// Direct snoozes
	const direct = collectSnoozeMatches(task.text, /* inherited */ false);
	if (direct.length && applies(direct, /* allowGlobal */ true)) {
		return true;
	}

	// Inherited snoozes by walking up parents
	let parentId = task._parentId;
	const seen = new Set<string>();
	while (parentId && !seen.has(parentId)) {
		seen.add(parentId);
		const parent = taskMap.get(parentId);
		if (!parent) break;
		const inh = collectSnoozeMatches(
			parent.text ?? "",
			/* inherited */ true
		);
		if (inh.length && applies(inh, /* allowGlobal */ true)) {
			return true;
		}
		parentId = parent._parentId;
	}

	return false;
};

/**
 * Returns whether a task is active for a specific member alias.
 * New-format only via inline wrappers:
 * <span data-template-key="members.assignee"
 *       data-assign-type="assignee"
 *       data-assignment-state="active|inactive"
 *       data-member-slug="<alias>">...</span>
 *
 * Semantics:
 * - active=true => must have an active marker and NOT have an inactive marker for the alias
 * - active=false => returns true if it has an inactive marker for the alias
 */
export const activeForMember = (
	task: TaskItem,
	active = true,
	selectedAlias?: string | null
): boolean => {
	const txt = task?.text ?? "";
	if (!selectedAlias) return false;

	const spans = parseAssigneeSpans(txt);
	const aliasLower = String(selectedAlias).toLowerCase();

	const hasActiveNew = spans.some(
		(s) =>
			s.assignType === "assignee" &&
			s.assignmentState === "active" &&
			(s.memberSlug ?? "").toLowerCase() === aliasLower
	);
	const hasInactiveNew = spans.some(
		(s) =>
			s.assignType === "assignee" &&
			s.assignmentState === "inactive" &&
			(s.memberSlug ?? "").toLowerCase() === aliasLower
	);

	if (active) {
		return hasActiveNew && !hasInactiveNew;
	} else {
		return hasInactiveNew;
	}
};

/**
 * Returns true if the task is assigned to any user.
 * New-format only via "assignee" wrappers.
 */
export const isAssignedToAnyUser = (task: TaskItem): boolean => {
	const txt = task?.text ?? "";
	const spans = parseAssigneeSpans(txt);
	return spans.some(
		(s) =>
			s.assignType === "assignee" &&
			s.assignmentState === "active" &&
			!!s.memberSlug
	);
};

/**
 * Returns true if the task is assigned to the provided member alias OR is an active team task.
 * New-format only:
 * - "Everyone" assignee via wrapper
 * - Member-specific via activeForMember
 */
export const isAssignedToMemberOrTeam = (
	task: TaskItem,
	selectedAlias?: string | null
): boolean => {
	const txt = task?.text ?? "";
	const spans = parseAssigneeSpans(txt);

	const hasEveryoneActiveNew = spans.some(
		(s) =>
			s.assignType === "assignee" &&
			s.assignmentState === "active" &&
			(s.memberSlug ?? "").toLowerCase() === "everyone"
	);

	return hasEveryoneActiveNew || activeForMember(task, true, selectedAlias);
};

/**
 * Returns true if task text is empty
 */
export const isBlankTask = (task: TaskItem): boolean => {
	const txt = task?.text;
	if (typeof txt !== "string") return true;
	return txt.trim().length === 0;
};



./src/features/task-filter/domain/types.ts
/**
 * Domain types and constants for task filtering and agile artifact classification.
 *
 * Centralizes:
 * - Branded union types for artifact categories
 * - Task status semantics (if not already exported by @features/tasks)
 * - Emoji tokens and tag/class tokens used by filters
 * - Common regex fragments
 */

export type AgileArtifactType =
	| "initiative"
	| "learning-initiative"
	| "epic"
	| "learning-epic"
	| "story"
	| "okr"
	| "recurring-responsibility"
	| "task";

/**
 * Known TaskItem status codes.
 * If @features/tasks exports a canonical enum, prefer importing that.
 */
export enum TaskStatusCode {
	Open = "O",
	Done = "d",
	Category = "A",
	// Add other known codes here as needed, ensuring clear semantics.
}

/**
 * Tokens and markers used within task text.
 */
export const Tokens = {
	CompletedEmoji: "✅",
	CancelledEmoji: "❌",
	SnoozeEmoji: "💤",
	SnoozeInheritedMarker: "⬇️",
	ActivePrefix: "active-",
	InactivePrefix: "inactive-",
	ActiveTeamClass: "active-team",
	// Calendar variations are handled via regex in filters for robustness.
} as const;

./src/features/task-filter/index.ts
/**
 * Public API surface for task-filter feature.
 *
 * Exposes:
 * - getAgileArtifactType
 * - Task filters and helpers
 */
export { getAgileArtifactType } from "./domain/agile-artifact-types";
export * from "./domain/task-filters";
export type { AgileArtifactType } from "./domain/types";

