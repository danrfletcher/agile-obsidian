./src/features/templating-params-editor/app/edit-template-params.ts
/**
 * Application service for editing template parameters in dashboard context.
 * Pure orchestration that uses provided ports for all side effects.
 */

import type { AppDeps } from "./ports";
import type {
	FileContextHint,
	TemplateParams,
	WrapperDomContext,
} from "../domain/types";
import {
	locateByInstanceId,
	locateFirstByKey,
	locateNearLineByKey,
} from "../domain/span-location";
import { validateAndSanitizeParams } from "../domain/validation";

/**
 * Preserve the existing data-template-wrapper instance id in newHtml if needed.
 */
function preserveInstanceIdInHtml(
	newHtml: string,
	instanceId?: string | null
): string {
	if (!instanceId) return newHtml;
	return newHtml.replace(
		/data-template-wrapper="[^"]*"/,
		`data-template-wrapper="${instanceId}"`
	);
}

/**
 * Attempt to normalize a prefilled dropdown value to an option value so the select
 * can preselect correctly. Useful when existing content stores "USD" but options store "$".
 */
function normalizeDropdownPrefillToOptionValue(
	prefillVal: unknown,
	options?: Array<{ label: string; value: string }>
): string | undefined {
	if (!options || options.length === 0)
		return prefillVal as string | undefined;
	const raw = prefillVal == null ? "" : String(prefillVal).trim();
	if (!raw) return undefined;

	// 1) Exact match by value
	const exact = options.find((o) => String(o.value) === raw);
	if (exact) return String(exact.value);

	// 2) Case-insensitive match by label containing the raw text (tolerate code vs symbol)
	const lower = raw.toLowerCase();
	const byLabel = options.find((o) =>
		String(o.label ?? "")
			.toLowerCase()
			.includes(lower)
	);
	if (byLabel) return String(byLabel.value);

	// 3) Fallback: return the raw string (the select will not preselect)
	return raw;
}

/**
 * Orchestrates the edit flow:
 * 1) Validate template and prefill params
 * 2) Ask user for new params (schema modal or JSON)
 * 3) Validate/sanitize params
 * 4) Render new HTML and optimistically update dashboard
 * 5) Replace wrapper in file via best-effort locating
 * 6) Persist, refresh and emit events
 */
export async function editTemplateParamsOnDashboard(
	ctx: WrapperDomContext,
	fileCtx: FileContextHint,
	deps: AppDeps
): Promise<void> {
	const { wrapperEl, templateKey, instanceId } = ctx;
	const { filePath, lineHint0 } = fileCtx;
	const { templating, vault, refresh, notices, eventBus } = deps;

	const def = templating.findTemplateById(templateKey);
	if (!def) {
		notices?.warn?.(`Unknown template: ${templateKey}`);
		return;
	}
	if (def.hiddenFromDynamicCommands) return;
	if (!def.hasParams) return;

	const prefill =
		templating.prefillTemplateParams(templateKey, wrapperEl) ??
		({} as TemplateParams);

	let params: TemplateParams | undefined;
	if (def.paramsSchema && def.paramsSchema.fields?.length) {
		// Merge defaults into the schema for nicer UX; For dropdowns, normalize prefill to an option value.
		const schema = {
			...def.paramsSchema,
			fields: def.paramsSchema.fields.map((f: any) => {
				const pre = prefill[f.name];
				let nextDefault = pre != null ? String(pre) : f.defaultValue;

				if (
					String(f.type) === "dropdown" &&
					Array.isArray(f.options) &&
					pre != null
				) {
					const normalized = normalizeDropdownPrefillToOptionValue(
						pre,
						f.options
					);
					if (normalized != null) {
						nextDefault = normalized;
					}
				}

				return {
					...f,
					defaultValue: nextDefault,
				};
			}),
		};
		params = await templating.showSchemaModal(templateKey, schema, true);
	} else {
		const jsonParams = JSON.stringify(prefill ?? {}, null, 2);
		params = await templating.showJsonModal(templateKey, jsonParams);
	}
	if (!params) return; // user cancelled

	// Validate/sanitize params
	const validation = validateAndSanitizeParams(
		params,
		def.paramsSchema as any
	);
	if (!validation.ok) {
		notices?.error?.(
			`Invalid parameters: ${validation.error ?? "Unknown error"}`
		);
		return;
	}
	const cleanParams = validation.value!;

	// Render and preserve instance id
	let newHtml = templating.renderTemplateOnly(templateKey, cleanParams);
	newHtml = preserveInstanceIdInHtml(newHtml, instanceId);

	// Optimistic UI update
	try {
		wrapperEl.outerHTML = newHtml;
	} catch {
		// ignore
	}

	eventBus?.dispatch("agile:prepare-optimistic-file-change", { filePath });

	// Persist change in file content
	let content: string;
	if (typeof vault.fileExists === "function") {
		const exists = await vault.fileExists(filePath);
		if (!exists) {
			throw new Error(`File not found: ${filePath}`);
		}
		content = await vault.readFile(filePath);
	} else {
		try {
			content = await vault.readFile(filePath);
		} catch {
			throw new Error(`File not found: ${filePath}`);
		}
	}

	// Locate in priority: instance id -> near line -> anywhere by key
	let spanRange: [number, number] | null = null;
	if (instanceId) {
		spanRange = locateByInstanceId(content, instanceId);
	}
	if (!spanRange && typeof lineHint0 === "number") {
		spanRange = locateNearLineByKey(content, templateKey, lineHint0);
	}
	if (!spanRange) {
		spanRange = locateFirstByKey(content, templateKey);
	}

	if (!spanRange) {
		throw new Error("Unable to locate template wrapper in file");
	}

	const [start, end] = spanRange;
	const updated = content.slice(0, start) + newHtml + content.slice(end);
	if (updated === content) {
		throw new Error("Template edit produced no changes");
	}

	await vault.writeFile(filePath, updated);

	// Refresh and emit event
	await refresh.refreshForFile(filePath);
	eventBus?.dispatch("agile:task-updated", { filePath });
}

./src/features/templating-params-editor/app/params-editor-service.ts
import { ParamsSchema } from "@features/templating-engine";

/**
 * Resolve the UI modal title for a params schema.
 */
export function resolveModalTitleFromSchema(
    schema: ParamsSchema | undefined,
    mode?: boolean | string
): string | undefined {
    if (!schema) return undefined;

    if (mode !== undefined) {
        const key = typeof mode === "string" ? mode : mode ? "edit" : "create";
        type TitleKey = keyof NonNullable<ParamsSchema["titles"]>; // "create" | "edit"
        const candidate = schema.titles?.[key as TitleKey];
        return candidate ?? schema.title;
    }
    return schema.title;
}
./src/features/templating-params-editor/app/ports.ts
/**
 * Ports define all external interactions for this feature.
 * Provide concrete implementations via your composition module.
 */

import type { TemplateParams, EventBusLike } from "../domain/types";
import type { ParamsSchema } from "@features/templating-engine";

/**
 * Minimal template definition shape expected by the params editor,
 * but using the templating-engine's rich ParamsSchema so dropdowns,
 * textarea, blockSelect, labels, placeholders, and options are preserved.
 */
export type TemplateDefForPorts = {
	id: string;
	hasParams: boolean;
	hiddenFromDynamicCommands?: boolean;
	paramsSchema?: ParamsSchema;
};

export interface TemplatingPorts {
	/**
	 * Lookup a template definition by id (aka templateKey).
	 * Must return the rich schema so the modal can render correct inputs.
	 */
	findTemplateById: (id: string) => TemplateDefForPorts | undefined;

	/**
	 * Attempt to prefill parameters from the wrapper element.
	 */
	prefillTemplateParams: (
		templateId: string,
		wrapperEl: HTMLElement
	) => TemplateParams | undefined;

	/**
	 * Render only the template body (wrapper included) with the given params.
	 */
	renderTemplateOnly: (templateId: string, params: TemplateParams) => string;

	/**
	 * Show a schema-driven modal using the rich templating-engine ParamsSchema.
	 * Return undefined on cancel.
	 */
	showSchemaModal: (
		templateId: string,
		schema: ParamsSchema,
		isEdit: boolean
	) => Promise<TemplateParams | undefined>;

	/**
	 * Show a JSON modal initialized with a JSON string.
	 * Should parse and return a params object, or undefined on cancel.
	 */
	showJsonModal: (
		templateId: string,
		initialJson: string
	) => Promise<TemplateParams | undefined>;
}

export interface VaultPort {
	readFile(path: string): Promise<string>;
	writeFile(path: string, content: string): Promise<void>;
	/**
	 * Optional existence check. If not provided, callers should readFile and handle not-found via throw.
	 */
	fileExists?: (path: string) => Promise<boolean>;
}

export interface RefreshPort {
	refreshForFile: (filePath?: string | null) => Promise<void>;
}

export interface NoticePort {
	info: (msg: string) => void;
	warn: (msg: string) => void;
	error: (msg: string) => void;
}

export interface AppDeps {
	templating: TemplatingPorts;
	vault: VaultPort;
	refresh: RefreshPort;
	notices?: NoticePort;
	eventBus?: EventBusLike;
}

./src/features/templating-params-editor/app/request-template-params.ts
import type { NoticePort } from "./ports";
import type { TemplateParams } from "../domain/types";
import { validateAndSanitizeParams } from "../domain/validation";

export type ParamsTemplatingPorts = {
	findTemplateById: (id: string) =>
		| {
				id: string;
				hasParams?: boolean;
				hiddenFromDynamicCommands?: boolean;
				paramsSchema?:
					| {
							title?: string;
							description?: string;
							fields?: Array<{
								name: string;
								label?: string;
								type?: string;
								placeholder?: string;
								defaultValue?: string | number | boolean | null;
								description?: string;
								required?: boolean;
								options?: Array<{
									label: string;
									value: string;
								}>;
							}>;
							titles?: { create?: string; edit?: string };
					  }
					| undefined;
		  }
		| undefined;

	showSchemaModal: (
		templateId: string,
		schema: {
			title?: string;
			description?: string;
			fields: Array<{
				name: string;
				label?: string;
				type?: "string" | "number" | "boolean" | "any" | string;
				placeholder?: string;
				defaultValue?: string | number | boolean | null;
				description?: string;
				required?: boolean;
				options?: Array<{ label: string; value: string }>;
			}>;
			titles?: { create?: string; edit?: string };
		},
		isEdit: boolean
	) => Promise<TemplateParams | undefined>;

	showJsonModal: (
		templateId: string,
		initialJson: string
	) => Promise<TemplateParams | undefined>;
};

/**
 * Unified parameter request flow for both "create" and "edit".
 * - Determines schema vs JSON modal
 * - Prefills defaults based on provided prefill map (strings)
 * - Validates/sanitizes against schema when provided
 * - Returns clean params or undefined if user cancels
 */
export async function requestTemplateParams(
	ports: ParamsTemplatingPorts,
	templateKey: string,
	prefill: Record<string, unknown> | undefined,
	isEdit: boolean,
	notices?: NoticePort
): Promise<TemplateParams | undefined> {
	const def = ports.findTemplateById(templateKey);
	if (!def) {
		notices?.warn?.(`Unknown template: ${templateKey}`);
		return undefined;
	}
	if (def.hiddenFromDynamicCommands) {
		// Assignee etc: do not open generic param modals
		return undefined;
	}
	if (!def.hasParams) {
		// Nothing to collect
		return {};
	}

	const prefillObj = prefill ?? {};
	const asString = (v: unknown): string =>
		v == null ? "" : typeof v === "string" ? v : String(v);

	let params: TemplateParams | undefined;

	if (
		def.paramsSchema &&
		Array.isArray(def.paramsSchema.fields) &&
		def.paramsSchema.fields.length > 0
	) {
		// Merge defaults into schema for better UX (editing shows current values)
		const merged = {
			...def.paramsSchema,
			fields: def.paramsSchema.fields.map((f) => ({
				...f,
				defaultValue:
					prefillObj[f.name] != null
						? asString(prefillObj[f.name])
						: f.defaultValue,
			})),
		};

		params = await ports.showSchemaModal(
			templateKey,
			merged as any,
			isEdit
		);
	} else {
		const json = JSON.stringify(prefillObj, null, 2);
		params = await ports.showJsonModal(templateKey, json);
	}

	if (!params) return undefined;

	// Validate/sanitize if there is a schema. Otherwise accept as-is.
	const validation = validateAndSanitizeParams(
		params,
		def.paramsSchema as any
	);
	if (!validation.ok) {
		notices?.error?.(
			`Invalid parameters: ${validation.error ?? "Unknown error"}`
		);
		return undefined;
	}
	return validation.value ?? {};
}

./src/features/templating-params-editor/domain/span-location.ts
/**
 * Span location and deterministic matching utilities.
 * These functions are pure and safe to unit test.
 */

export function escapeRegExp(s: string): string {
	return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/**
 * Given the file content and the absolute index of an opening <span ...>,
 * find the absolute end index (exclusive) of its matching </span>, accounting for nested spans.
 * Returns -1 if not found.
 */
export function findMatchingSpanEndIndexDeterministic(
	s: string,
	startIdx: number
): number {
	const lower = s.toLowerCase();
	if (lower.slice(startIdx, startIdx + 5) !== "<span") {
		const firstOpen = lower.indexOf("<span", startIdx);
		if (firstOpen === -1) return -1;
		startIdx = firstOpen;
	}
	const firstGt = s.indexOf(">", startIdx);
	if (firstGt === -1) return -1;

	let depth = 1;
	let i = firstGt + 1;
	while (i < s.length) {
		const nextOpen = lower.indexOf("<span", i);
		const nextClose = lower.indexOf("</span>", i);
		if (nextClose === -1) return -1;

		if (nextOpen !== -1 && nextOpen < nextClose) {
			const gt = s.indexOf(">", nextOpen);
			if (gt === -1) return -1;
			depth += 1;
			i = gt + 1;
			continue;
		}
		depth -= 1;
		const closeEnd = nextClose + "</span>".length;
		if (depth === 0) return closeEnd;
		i = closeEnd;
	}
	return -1;
}

export function offsetOfLineStart(lines: string[], lineNo: number): number {
	let off = 0;
	for (let i = 0; i < lineNo; i++) {
		off += lines[i].length + 1; // include newline
	}
	return off;
}

/**
 * Locate a wrapper block by unique instance id.
 * Returns [startIndex, endIndexExclusive] or null.
 */
export function locateByInstanceId(
	content: string,
	instanceId: string
): [number, number] | null {
	const re = new RegExp(
		`<span\\b[^>]*\\bdata-template-wrapper\\s*=\\s*"` +
			escapeRegExp(instanceId) +
			`"[\\s\\S]*?>`,
		"i"
	);
	const m = re.exec(content);
	if (!m || typeof m.index !== "number") return null;
	const startIndex = m.index;
	const endIndex = findMatchingSpanEndIndexDeterministic(content, startIndex);
	if (endIndex === -1) return null;
	return [startIndex, endIndex];
}

/**
 * Locate a wrapper block by template key near a specific line number (lineHint0 and neighbors).
 * Returns [startIndex, endIndexExclusive] or null.
 */
export function locateNearLineByKey(
	content: string,
	templateKey: string,
	lineHint0: number
): [number, number] | null {
	const lines = content.split(/\r?\n/);
	const idxs = [lineHint0, lineHint0 - 1, lineHint0 + 1].filter(
		(i) => i >= 0 && i < lines.length
	);
	const re = new RegExp(
		`<span\\b[^>]*\\bdata-template-key\\s*=\\s*"` +
			escapeRegExp(templateKey) +
			`"[\\s\\S]*?>`,
		"i"
	);
	for (const li of idxs) {
		const line = lines[li];
		const m = re.exec(line);
		if (!m) continue;
		const openIdx = m.index;
		const absStart = offsetOfLineStart(lines, li) + openIdx;
		const absEnd = findMatchingSpanEndIndexDeterministic(content, absStart);
		if (absEnd !== -1) {
			return [absStart, absEnd];
		}
	}
	return null;
}

/**
 * Locate the first wrapper block in the entire file by template key.
 * Returns [startIndex, endIndexExclusive] or null.
 */
export function locateFirstByKey(
	content: string,
	templateKey: string
): [number, number] | null {
	const re = new RegExp(
		`<span\\b[^>]*\\bdata-template-key\\s*=\\s*"` +
			escapeRegExp(templateKey) +
			`"[\\s\\S]*?>`,
		"i"
	);
	const m = re.exec(content);
	if (!m || typeof m.index !== "number") return null;
	const startIndex = m.index;
	const endIndex = findMatchingSpanEndIndexDeterministic(content, startIndex);
	if (endIndex === -1) return null;
	return [startIndex, endIndex];
}

./src/features/templating-params-editor/domain/types.ts
/**
 * Core domain types for the templating params editor.
 */

export interface EventBusLike {
	dispatch<N extends string>(name: N, payload: any): void;
}

export interface ParamField {
	name: string;
	type?: "string" | "number" | "boolean" | "any";
	required?: boolean;
	defaultValue?: string;
}

export interface ParamsSchema {
	fields: ParamField[];
}

export interface TemplateDef {
	id: string;
	hasParams: boolean;
	hiddenFromDynamicCommands?: boolean;
	paramsSchema?: ParamsSchema;
}

export type TemplateParams = Record<string, unknown>;

export interface WrapperDomContext {
	// The span element clicked
	wrapperEl: HTMLElement;
	// The unique instance id (from data-template-wrapper), if present
	instanceId?: string | null;
	// The template key id (from data-template-key)
	templateKey: string;
}

export interface FileContextHint {
	filePath: string;
	lineHint0?: number | null;
}

./src/features/templating-params-editor/domain/validation.ts
/**
 * Lightweight schema-based validation/sanitization for template params.
 * We intentionally keep this simple: ensure required fields exist, coerce basic types,
 * strip unknown fields if a schema is provided.
 */

import type { ParamField, ParamsSchema, TemplateParams } from "./types";

function coerce(value: unknown, type: ParamField["type"]): unknown {
	switch (type) {
		case "number": {
			const n = typeof value === "number" ? value : Number(value);
			return Number.isFinite(n) ? n : undefined;
		}
		case "boolean": {
			if (typeof value === "boolean") return value;
			if (typeof value === "string") {
				const v = value.trim().toLowerCase();
				if (v === "true") return true;
				if (v === "false") return false;
			}
			return undefined;
		}
		case "string": {
			if (value == null) return "";
			return String(value);
		}
		case "any":
		default:
			return value;
	}
}

export interface ValidationResult {
	ok: boolean;
	value?: TemplateParams;
	error?: string;
}

/**
 * Validate and sanitize params against the provided schema (if present).
 * - Unknown fields are removed when a schema exists.
 * - Required fields without a value are filled from defaultValue (if available) or flagged as error.
 * - Basic type coercion is applied.
 */
export function validateAndSanitizeParams(
	raw: TemplateParams,
	schema?: ParamsSchema
): ValidationResult {
	if (!schema || !schema.fields || schema.fields.length === 0) {
		// No schema: accept as-is
		return { ok: true, value: raw };
	}

	const fieldsByName = new Map<string, ParamField>();
	for (const f of schema.fields) fieldsByName.set(f.name, f);

	const sanitized: TemplateParams = {};
	for (const field of schema.fields) {
		const inputVal = raw[field.name];
		let val = inputVal;

		if (val == null || (typeof val === "string" && val.trim() === "")) {
			if (field.defaultValue != null) {
				val = field.defaultValue;
			} else if (field.required) {
				return {
					ok: false,
					error: `Missing required field: ${field.name}`,
				};
			} else {
				val = undefined;
			}
		}

		const coerced = coerce(val, field.type ?? "any");
		if (field.required && coerced === undefined) {
			return {
				ok: false,
				error: `Invalid value for required field: ${field.name}`,
			};
		}
		if (coerced !== undefined) {
			sanitized[field.name] = coerced;
		}
	}

	// Unknown keys are dropped
	return { ok: true, value: sanitized };
}

./src/features/templating-params-editor/index.ts
/**
 * Barrel export for the templating-params-editor feature.
 * This module is wiring-agnostic. Provide concrete ports via your composition module.
 */

export type { EventBusLike, TemplateParams, TemplateDef } from "./domain/types";
export type {
	TemplatingPorts,
	VaultPort,
	RefreshPort,
	NoticePort,
} from "./app/ports";

export { attachDashboardTemplatingHandler } from "./ui/handlers/dashboard-click-handler";

// New: editor handler for regular notes (Markdown editor/live preview)
export { attachEditorTemplatingHandler } from "./ui/handlers/editor-click-handler";

// Unified parameter collection for create/edit flows
export type { ParamsTemplatingPorts } from "./app/request-template-params";
export { requestTemplateParams } from "./app/request-template-params";

export { showSchemaModal } from "./ui/modals/template-schema-modal";
export { showJsonModal } from "./ui/modals/template-json-modal";

./src/features/templating-params-editor/ui/handlers/dashboard-click-handler.ts
/**
 * UI click handler that intercepts clicks on template wrappers,
 * extracts context, and delegates to the application service.
 */

import type { App } from "obsidian";
import { Notice } from "obsidian";
import { editTemplateParamsOnDashboard } from "../../app/edit-template-params";
import type { AppDeps, RefreshPort } from "../../app/ports";

export interface AttachHandlerOptions {
	app: App;
	viewContainer: HTMLElement; // e.g., this.containerEl.children[1]
	registerDomEvent: (
		el: HTMLElement | Window | Document,
		type: string,
		handler: (evt: any) => void,
		options?: AddEventListenerOptions | boolean
	) => void;

	// Required ports
	deps: AppDeps;

	// For backward compat: allow passing refresh separately in case deps.refresh is shared
	refresh?: RefreshPort;

	// Optional: provide a Notice adapter. If not provided, default to Obsidian Notice.
	useObsidianNotice?: boolean;
}

/**
 * Attach the dashboard templating handler.
 * Returns a cleanup no-op; Obsidian will clean up via registerDomEvent lifecycle.
 */
export function attachDashboardTemplatingHandler(
	opts: AttachHandlerOptions
): () => void {
	const {
		viewContainer,
		registerDomEvent,
		deps,
		useObsidianNotice = true,
	} = opts;

	const notices =
		deps.notices ??
		(useObsidianNotice
			? {
					info: (msg: string) => new Notice(msg, 3000),
					warn: (msg: string) => new Notice(`Warning: ${msg}`, 5000),
					error: (msg: string) => new Notice(`Error: ${msg}`, 8000),
			  }
			: undefined);

	const onClick = async (evt: MouseEvent) => {
		try {
			const target = evt.target as HTMLElement | null;
			if (!target) return;

			const wrapper = target.closest(
				"span[data-template-wrapper][data-template-key]"
			) as HTMLElement | null;
			if (!wrapper) return;

			const templateKey = wrapper.getAttribute("data-template-key") || "";
			if (!templateKey) return;

			// Resolve template def BEFORE cancelling so other handlers (e.g., assignment) can run if we skip
			const def = deps.templating.findTemplateById(templateKey);
			if (!def || def.hiddenFromDynamicCommands || !def.hasParams) {
				return; // do not cancel; let the assignment handler handle it
			}

			// We will handle this: cancel default and stop propagation
			evt.preventDefault();
			evt.stopPropagation();
			// @ts-ignore
			evt.stopImmediatePropagation?.();

			const li = wrapper.closest(
				"li[data-file-path]"
			) as HTMLElement | null;
			const filePath = li?.getAttribute("data-file-path") || "";
			if (!filePath) return;

			const lineHintStr = li?.getAttribute("data-line") || "";
			const lineHint0 =
				lineHintStr && /^\d+$/.test(lineHintStr)
					? parseInt(lineHintStr, 10)
					: null;

			await editTemplateParamsOnDashboard(
				{
					wrapperEl: wrapper,
					templateKey,
					instanceId: wrapper.getAttribute("data-template-wrapper"),
				},
				{
					filePath,
					lineHint0,
				},
				{
					...deps,
					notices,
				}
			);
		} catch (err) {
			const msg = `Template edit failed: ${String(
				(err as Error)?.message ?? err
			)}`;
			if (useObsidianNotice) new Notice(msg);
			else deps.notices?.error?.(msg);
		}
	};

	registerDomEvent(viewContainer, "click", onClick, { capture: true });
	return () => {};
}
./src/features/templating-params-editor/ui/handlers/editor-click-handler.ts
/**
 * UI click handler for editing template parameters inside regular notes (Markdown editor).
 * Works in the editor's content DOM (live preview), independent of dashboard structure.
 */

import type { App } from "obsidian";
import { Notice } from "obsidian";
import { editTemplateParamsOnDashboard } from "../../app/edit-template-params";
import type { AppDeps, RefreshPort } from "../../app/ports";

type RegisterDomEvent = (
	el: HTMLElement | Window | Document,
	type: string,
	handler: (evt: any) => void,
	options?: AddEventListenerOptions | boolean
) => void;

export interface AttachEditorHandlerOptions {
	app: App;
	viewContainer: HTMLElement; // e.g., CodeMirror content DOM (.cm-content) or view.containerEl
	registerDomEvent: RegisterDomEvent;

	// Required ports
	deps: AppDeps;

	// File to update (current note path)
	filePath: string;

	// Optional hint: get a line number (0-based) at click time; will be used if instanceId is absent
	getLineHint0?: () => number | null;

	// Optional: provide a Notice adapter. If not provided and useObsidianNotice=true, default to Obsidian Notice.
	useObsidianNotice?: boolean;

	// For backward compat: allow passing refresh separately in case deps.refresh is shared
	refresh?: RefreshPort;
}

/**
 * Attach an editor templating handler.
 * Intercepts clicks on spans with data-template-wrapper and data-template-key, opens edit flow,
 * and persists changes to the current file.
 */
export function attachEditorTemplatingHandler(
	opts: AttachEditorHandlerOptions
): () => void {
	const {
		viewContainer,
		registerDomEvent,
		deps,
		filePath,
		getLineHint0,
		useObsidianNotice = true,
	} = opts;

	const notices =
		deps.notices ??
		(useObsidianNotice
			? {
					info: (msg: string) => new Notice(msg, 3000),
					warn: (msg: string) => new Notice(`Warning: ${msg}`, 5000),
					error: (msg: string) => new Notice(`Error: ${msg}`, 8000),
			  }
			: undefined);

	const onClick = async (evt: MouseEvent) => {
		try {
			const target = evt.target as HTMLElement | null;
			if (!target) return;

			// Detect parameterized template wrapper (rendered in live preview)
			const wrapper = target.closest(
				"span[data-template-wrapper][data-template-key]"
			) as HTMLElement | null;
			if (!wrapper) return;

			const templateKey = wrapper.getAttribute("data-template-key") || "";
			if (!templateKey) return;

			// Resolve template def BEFORE cancelling the event so other handlers can run if we don't handle it
			const def = deps.templating.findTemplateById(templateKey);
			// Skip generic edit flow for hidden templates (e.g., members.assignee) or templates without params
			if (!def || def.hiddenFromDynamicCommands || !def.hasParams) {
				return; // allow task-assignment and other handlers to receive the click
			}

			// Current file path is required to persist changes
			if (!filePath) return;

			// We will handle this click: cancel default and stop propagation
			evt.preventDefault();
			evt.stopPropagation();
			// @ts-ignore
			evt.stopImmediatePropagation?.();

			const instanceId =
				wrapper.getAttribute("data-template-wrapper") || undefined;

			const lineHint0 =
				typeof getLineHint0 === "function" ? getLineHint0() : null;

			await editTemplateParamsOnDashboard(
				{
					wrapperEl: wrapper,
					templateKey,
					instanceId,
				},
				{
					filePath,
					lineHint0: lineHint0 ?? null,
				},
				{
					...deps,
					notices, // default to Obsidian Notice if not provided
				}
			);
		} catch (err) {
			const msg = `Template edit failed: ${String(
				(err as Error)?.message ?? err
			)}`;
			if (useObsidianNotice) new Notice(msg);
			else deps.notices?.error?.(msg);
		}
	};

	// Use capture to intercept clicks before default behaviors in the editor
	registerDomEvent(viewContainer, "click", onClick, { capture: true });

	// Obsidian will auto-clean via registerDomEvent. Return no-op for interface symmetry.
	return () => {};
}

./src/features/templating-params-editor/ui/modals/template-json-modal.ts
import { App, Modal, Notice } from "obsidian";

export async function showJsonModal(
	app: App,
	templateId: string,
	initialJson?: string
): Promise<unknown | undefined> {
	return new Promise((resolve) => {
		const modal = new (class extends Modal {
			private textarea!: HTMLTextAreaElement;
			private resolved = false;

			onOpen(): void {
				this.titleEl.setText(`Params for ${templateId}`);
				const { contentEl } = this;

				const para = contentEl.createEl("p", {
					text: 'Enter template params as JSON (optional). Example: {"title":"My Title"}',
				});
				para.style.marginBottom = "8px";

				this.textarea = contentEl.createEl("textarea", {
					attr: { rows: "10", style: "width: 100%;" },
				});
				if (initialJson) this.textarea.value = initialJson;

				const btnRow = contentEl.createEl("div", {
					attr: { style: "display:flex; gap:8px; margin-top: 12px;" },
				});

				const okBtn = btnRow.createEl("button", { text: "Apply" });
				const cancelBtn = btnRow.createEl("button", { text: "Cancel" });

				okBtn.addEventListener("click", () => {
					if (this.resolved) return;
					this.resolved = true;
					const v = this.textarea.value.trim();
					if (!v) {
						this.close();
						resolve(undefined);
						return;
					}
					try {
						const parsed = JSON.parse(v);
						this.close();
						resolve(parsed);
					} catch (e) {
						const msg = (e as Error)?.message ?? "Parse error";
						new Notice(`Invalid JSON: ${msg}`);
						this.resolved = false;
					}
				});

				cancelBtn.addEventListener("click", () => {
					if (this.resolved) return;
					this.resolved = true;
					this.close();
					resolve(undefined);
				});
			}

			onClose(): void {
				this.contentEl.empty();
			}
		})(app);

		modal.open();
	});
}

./src/features/templating-params-editor/ui/modals/template-schema-modal.ts
import { App, Modal, Notice } from "obsidian";
import type {
	ParamsSchema,
	ParamsSchemaField,
} from "@features/templating-engine";
import { resolveModalTitleFromSchema } from "../../app/params-editor-service";
import { escapeHtml } from "@utils";

/**
 Helpers and types for blockSelect
*/

type FileCandidate = {
	kind: "file";
	filePath: string; // full path
	basename: string; // file name without extension
	display: string; // for list rendering
	matchText: string; // for searching
};

type BlockCandidate = {
	kind: "block";
	filePath: string;
	line: number; // 0-based
	text: string; // line text (trimmed for display/search)
	blockId?: string; // if detected on the line
	display: string; // "text — path"
	matchText: string; // for searching (text + path)
};

type VaultIndex = {
	files: FileCandidate[];
	blocks: BlockCandidate[];
	builtAt: number;
};

function filenameFromPath(filePath: string): string {
	const name = (filePath.split("/").pop() || filePath).trim();
	return name.toLowerCase().endsWith(".md") ? name.slice(0, -3) : name;
}

// Module-scope cache (built on first use)
let vaultIndexPromise: Promise<VaultIndex> | null = null;

function detectBlockIdInLine(line: string): string | undefined {
	const m =
		/(?:^|\s)\^([a-zA-Z0-9-]{3,})\s*$/.exec(line) ||
		/(?:^|\s)\^([a-zA-Z0-9-]{3,})\b/.exec(line);
	return m ? m[1] : undefined;
}

function toDisplayPath(filePath: string): string {
	return filePath;
}

function makeFileCandidate(file: any): FileCandidate {
	const filePath = String(file.path ?? "");
	const basename = String(file.basename ?? filePath);
	return {
		kind: "file",
		filePath,
		basename,
		display: basename,
		matchText: `${basename} ${filePath}`.toLowerCase(),
	};
}

function makeBlockCandidate(
	filePath: string,
	line: number,
	raw: string
): BlockCandidate {
	const text = raw.trim();
	const bid = detectBlockIdInLine(raw);
	const displayText = text.length > 120 ? text.slice(0, 117) + "…" : text;
	const pathDisp = toDisplayPath(filePath);
	return {
		kind: "block",
		filePath,
		line,
		text,
		blockId: bid,
		display: `${displayText} — ${pathDisp}`,
		matchText: `${text} ${pathDisp}`.toLowerCase(),
	};
}

async function buildVaultIndex(app: App): Promise<VaultIndex> {
	const files = (app.vault as any).getMarkdownFiles?.() ?? [];
	const fileCandidates: FileCandidate[] = files.map(makeFileCandidate);

	const blocks: BlockCandidate[] = [];
	for (const f of files) {
		try {
			const content: string = await (app.vault as any).read(f);
			const lines = content.split(/\r?\n/);
			for (let i = 0; i < lines.length; i++) {
				const raw = lines[i];
				if (!raw || !raw.trim()) continue;
				blocks.push(makeBlockCandidate(String(f.path), i, raw));
			}
		} catch {
			// skip unreadable files
		}
	}

	return {
		files: fileCandidates,
		blocks,
		builtAt: Date.now(),
	};
}

function ensureIndex(app: App): Promise<VaultIndex> {
	if (!vaultIndexPromise) {
		vaultIndexPromise = buildVaultIndex(app);
	}
	return vaultIndexPromise;
}

function generateBlockId(): string {
	return Math.random().toString(36).slice(2, 10);
}

async function ensureBlockIdOnLine(
	app: App,
	filePath: string,
	lineIndex: number
): Promise<string> {
	const abstractFile: any = (app.vault as any).getAbstractFileByPath(
		filePath
	);
	if (!abstractFile) {
		throw new Error(`File not found: ${filePath}`);
	}
	const content: string = await (app.vault as any).read(abstractFile);
	const lines = content.split(/\r?\n/);
	if (lineIndex < 0 || lineIndex >= lines.length) {
		throw new Error(`Invalid line index ${lineIndex} for ${filePath}`);
	}
	let line = lines[lineIndex];

	const existing = detectBlockIdInLine(line);
	if (existing) return existing;

	let newId = generateBlockId();
	const isIdInFile = (id: string) =>
		lines.some((ln) => new RegExp(`(?:^|\\s)\\^${id}(?:\\s|$)`).test(ln));
	let attempts = 0;
	while (isIdInFile(newId) && attempts < 5) {
		newId = generateBlockId();
		attempts++;
	}

	line = line.replace(/\s+$/, "");
	lines[lineIndex] = `${line} ^${newId}`;

	const nextContent = lines.join("\n");
	await (app.vault as any).modify(abstractFile, nextContent);

	return newId;
}

/**
 * Suggestion portal: render dropdown as a child of document.body to avoid clipping inside modals.
 */
function createSuggestionPortal(): HTMLUListElement {
	const ul = document.createElement("ul");
	ul.style.position = "fixed"; // attach to viewport; easy to align via rect
	ul.style.zIndex = "999999"; // above modal
	ul.style.maxHeight = "320px"; // reasonable cap
	ul.style.overflowY = "auto";
	ul.style.margin = "0";
	ul.style.padding = "6px";
	ul.style.listStyle = "none";
	ul.style.background = "var(--background-primary)";
	ul.style.border = "1px solid var(--background-modifier-border)";
	ul.style.borderRadius = "6px";
	ul.style.boxShadow = "var(--shadow-s)";
	ul.style.display = "none";
	ul.style.minWidth = "240px"; // keep usable width
	document.body.appendChild(ul);
	return ul;
}

function clearChildren(el: HTMLElement) {
	while (el.firstChild) el.removeChild(el.firstChild);
}

function normalizeQuery(q: string): string {
	return q.trim().toLowerCase();
}

type SuggestionItem = FileCandidate | BlockCandidate;

function filterSuggestions(
	index: VaultIndex,
	rawQuery: string,
	limit = 50
): SuggestionItem[] {
	const q = normalizeQuery(rawQuery);
	if (!q) return [];

	const hatIdx = q.indexOf("^");
	if (hatIdx >= 0) {
		const fileQ = q.slice(0, hatIdx).trim();
		const blockQ = q.slice(hatIdx + 1).trim();

		const inFiles =
			fileQ.length > 0
				? index.files
						.filter(
							(f) =>
								f.matchText.includes(fileQ) ||
								f.filePath.toLowerCase().includes(fileQ)
						)
						.map((f) => f.filePath.toLowerCase())
				: null;

		const candidates = index.blocks.filter((b) => {
			const inFile =
				!inFiles || inFiles.includes(b.filePath.toLowerCase());
			const blockOk =
				!blockQ ||
				b.matchText.includes(blockQ) ||
				(b.blockId ? b.blockId.toLowerCase().includes(blockQ) : false);
			return inFile && blockOk;
		});

		return candidates.slice(0, limit);
	}

	const files = index.files.filter(
		(f) =>
			f.matchText.includes(q) ||
			f.filePath.toLowerCase().includes(q) ||
			f.basename.toLowerCase().includes(q)
	);
	const blocks = index.blocks.filter(
		(b) =>
			b.matchText.includes(q) ||
			(b.blockId ? b.blockId.toLowerCase().includes(q) : false)
	);

	const out: SuggestionItem[] = [];
	for (let i = 0; i < Math.min(files.length, 10); i++) out.push(files[i]);
	for (let i = 0; i < blocks.length && out.length < limit; i++)
		out.push(blocks[i]);
	return out.slice(0, limit);
}

/**
 * Rendering helpers for block previews
 */
function looksLikeHtml(s: string): boolean {
	return /<\/?[a-z][\s\S]*>/i.test(s);
}

function sanitizeHtml(raw: string): string {
	let s = raw;
	s = s.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, "");
	s = s.replace(/<style[\s\S]*?>[\s\S]*?<\/style>/gi, "");
	s = s.replace(/\s+on\w+\s*=\s*"(?:[^"]*)"/gi, "");
	s = s.replace(/\s+on\w+\s*=\s*'(?:[^']*)'/gi, "");
	s = s.replace(/\s+(href|src|action)\s*=\s*"(?:\s*javascript:[^"]*)"/gi, "");
	s = s.replace(/\s+(href|src|action)\s*=\s*'(?:\s*javascript:[^']*)'/gi, "");
	return s;
}

function splitListOrTaskPrefix(s: string): {
	leadingHTML: string;
	content: string;
} {
	const task = /^\s*-\s+\[([^\]]*)\]\s*(.*)$/s.exec(s);
	if (task) {
		const inside = task[1] ?? "";
		const content = task[2] ?? "";
		const checked = /x/i.test(inside);
		const leading = `<input type="checkbox" ${
			checked ? "checked" : ""
		} disabled style="pointer-events:none;margin-right:6px;vertical-align:middle;" />`;
		return { leadingHTML: leading, content };
	}
	const list = /^\s*-\s+(.*)$/s.exec(s);
	if (list) {
		const content = list[1] ?? "";
		const leading = `<span style="display:inline-block;width:0.8em;text-align:center;">•</span>&nbsp;`;
		return { leadingHTML: leading, content };
	}
	return { leadingHTML: "", content: s };
}

function renderBlockLinePreview(item: BlockCandidate): string {
	const { leadingHTML, content } = splitListOrTaskPrefix(item.text);
	const contentHtml = looksLikeHtml(content)
		? sanitizeHtml(content)
		: escapeHtml(content);
	const pathHtml = escapeHtml(toDisplayPath(item.filePath));
	return `🔗 ${leadingHTML}${contentHtml}<span style="color: var(--text-muted);"> — ${pathHtml}</span>`;
}

function renderSuggestionItem(
	li: HTMLLIElement,
	item: SuggestionItem,
	highlight = false
) {
	li.style.display = "block";
	li.style.padding = "6px 8px";
	li.style.cursor = "pointer";
	li.style.borderRadius = "4px";
	li.style.whiteSpace = "nowrap";
	li.style.overflow = "hidden";
	li.style.textOverflow = "ellipsis";
	li.style.background = highlight
		? "var(--background-modifier-hover)"
		: "transparent";
	li.setAttr("data-kind", item.kind);

	if (item.kind === "file") {
		li.innerHTML = `📄 ${escapeHtml(item.display)}`;
		li.title = item.filePath;
	} else {
		li.innerHTML = renderBlockLinePreview(item);
		li.title = `${item.filePath}:${item.line + 1}`;
	}
}

/**
 * Position a fixed-position portal under (or above) the input element.
 */
function positionPortalBelowInput(
	portal: HTMLUListElement,
	input: HTMLInputElement
) {
	const rect = input.getBoundingClientRect();
	const viewportH =
		window.innerHeight || document.documentElement.clientHeight;

	// Defaults: below the input
	let top = rect.bottom + 4;
	let maxHeight = Math.min(320, viewportH - top - 12);

	// If not enough space below, place above
	if (maxHeight < 120) {
		const spaceAbove = rect.top - 12;
		maxHeight = Math.min(320, spaceAbove - 4);
		top = Math.max(8, rect.top - maxHeight - 4);
	}

	portal.style.left = `${Math.round(rect.left)}px`;
	portal.style.top = `${Math.round(top)}px`;
	portal.style.width = `${Math.round(rect.width)}px`;
	portal.style.maxHeight = `${Math.max(120, Math.floor(maxHeight))}px`;
}

/**
 * Attach blockSelect input with body-portal suggestions (prevents clipping in modals).
 */
function attachBlockSelectInput(
	app: App,
	wrap: HTMLElement,
	field: ParamsSchemaField
): HTMLInputElement {
	// Minimal styling for the input wrapper; portal handles dropdown
	const inputEl = wrap.createEl("input", {
		attr: {
			type: "text",
			style: "width: 100%;",
			placeholder: String(field.placeholder ?? "Start typing…"),
			value: String(field.defaultValue ?? ""),
		},
	});

	const statusEl = wrap.createEl("div");
	statusEl.style.fontSize = "12px";
	statusEl.style.color = "var(--text-muted)";
	statusEl.style.marginTop = "4px";
	statusEl.style.display = "none";

	// Create body-attached portal for suggestions
	const ul = createSuggestionPortal();

	let suggestions: SuggestionItem[] = [];
	let highlightIndex = -1;
	let idx: VaultIndex | null = null;
	let indexing = false;
	let portalOpen = false;

	const openPortal = () => {
		if (!portalOpen) {
			portalOpen = true;
			ul.style.display = "block";
			positionPortalBelowInput(ul, inputEl);
		}
	};
	const closePortal = () => {
		if (portalOpen) {
			ul.style.display = "none";
			highlightIndex = -1;
			portalOpen = false;
		}
	};

	function renderSuggestions() {
		clearChildren(ul);
		suggestions.forEach((s, i) => {
			const li = document.createElement("li");
			renderSuggestionItem(li, s, i === highlightIndex);
			li.addEventListener("mouseenter", () => {
				highlightIndex = i;
				Array.from(ul.children).forEach((child, j) => {
					(child as HTMLElement).style.background =
						j === highlightIndex
							? "var(--background-modifier-hover)"
							: "transparent";
				});
			});
			li.addEventListener("mousedown", async (e) => {
				e.preventDefault();
				e.stopPropagation();
				await handleSelect(s);
			});
			ul.appendChild(li);
		});
		if (suggestions.length > 0) openPortal();
		else closePortal();
	}

	async function handleSelect(item: SuggestionItem) {
		if (item.kind === "file") {
			inputEl.value = `${filenameFromPath(item.filePath)}#^`;
			inputEl.focus();
			updateSuggestions();
			return;
		}
		try {
			const id =
				item.blockId ??
				(await ensureBlockIdOnLine(app, item.filePath, item.line));
			inputEl.value = `${filenameFromPath(item.filePath)}#^${id}`;
			closePortal();
		} catch (e) {
			new Notice(
				`Failed to set block id: ${String((e as Error)?.message ?? e)}`
			);
		}
	}

	async function ensureIndexReady() {
		if (idx || indexing) return;
		indexing = true;
		statusEl.style.display = "block";
		statusEl.textContent = "Indexing vault…";
		try {
			idx = await ensureIndex(app);
		} catch (e) {
			new Notice(
				`Failed to index vault: ${String((e as Error)?.message ?? e)}`
			);
		} finally {
			indexing = false;
			statusEl.style.display = "none";
		}
	}

	function updateSuggestions() {
		if (!idx) {
			closePortal();
			return;
		}
		const q = inputEl.value;
		if (!q || !q.trim()) {
			closePortal();
			return;
		}
		suggestions = filterSuggestions(idx, q, 50);
		highlightIndex = suggestions.length > 0 ? 0 : -1;
		renderSuggestions();
		positionPortalBelowInput(ul, inputEl);
	}

	// Event handlers
	inputEl.addEventListener("focus", async () => {
		await ensureIndexReady();
		updateSuggestions();
	});

	inputEl.addEventListener("input", () => {
		updateSuggestions();
	});

	inputEl.addEventListener("keydown", async (evt) => {
		if (!portalOpen) return;

		if (evt.key === "ArrowDown") {
			evt.preventDefault();
			if (suggestions.length === 0) return;
			highlightIndex = (highlightIndex + 1) % suggestions.length;
			renderSuggestions();
		} else if (evt.key === "ArrowUp") {
			evt.preventDefault();
			if (suggestions.length === 0) return;
			highlightIndex =
				(highlightIndex - 1 + suggestions.length) % suggestions.length;
			renderSuggestions();
		} else if (evt.key === "Enter") {
			if (highlightIndex >= 0 && highlightIndex < suggestions.length) {
				evt.preventDefault();
				const item = suggestions[highlightIndex];
				await handleSelect(item);
			}
		} else if (evt.key === "Escape") {
			evt.preventDefault();
			closePortal();
		}
	});

	// Reposition portal on scroll/resize
	const onViewportChange = () => {
		if (portalOpen) positionPortalBelowInput(ul, inputEl);
	};
	window.addEventListener("scroll", onViewportChange, true);
	window.addEventListener("resize", onViewportChange);

	// Close when clicking outside input or portal
	const onDocMouseDown = (e: MouseEvent) => {
		const t = e.target as Node | null;
		if (!t) return;
		if (t === inputEl || inputEl.contains(t)) return;
		if (t === ul || ul.contains(t)) return;
		closePortal();
	};
	document.addEventListener("mousedown", onDocMouseDown, { capture: true });

	// Cleanup when input wrapper is detached (modal close)
	const cleanup = () => {
		try {
			window.removeEventListener("scroll", onViewportChange, true);
			window.removeEventListener("resize", onViewportChange);
			document.removeEventListener("mousedown", onDocMouseDown, {
				capture: true as any,
			} as any);
			if (ul && ul.parentNode) ul.parentNode.removeChild(ul);
		} catch {
			// ignore
		}
	};
	// When the modal closes, Obsidian removes contentEl; observe detach
	const obs = new MutationObserver(() => {
		if (!document.body.contains(inputEl)) {
			cleanup();
			obs.disconnect();
		}
	});
	obs.observe(document.body, { childList: true, subtree: true });

	return inputEl;
}

export async function showSchemaModal(
	app: App,
	templateId: string,
	schema: ParamsSchema,
	isEdit = false
): Promise<Record<string, unknown> | undefined> {
	return new Promise((resolve) => {
		const modal = new (class extends Modal {
			private resolved = false;
			private inputs: Record<
				string,
				HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
			> = {};

			onOpen(): void {
				const { contentEl } = this;

				const title =
					resolveModalTitleFromSchema(schema, isEdit) ||
					schema.title ||
					`Parameters for ${templateId}`;
				this.titleEl.setText(title);

				if (schema.description) {
					const p = contentEl.createEl("p", {
						text: schema.description,
					});
					p.style.marginBottom = "8px";
				}

				let firstFocusableName: string | null = null;

				for (const field of (schema.fields ??
					[]) as ParamsSchemaField[]) {
					const wrap = contentEl.createEl("div", {
						attr: { style: "margin-bottom: 10px;" },
					});

					const labelEl = wrap.createEl("label", {
						text:
							(field.label ?? field.name) +
							(field.required ? " *" : ""),
					});
					labelEl.style.display = "block";
					labelEl.style.fontWeight = "600";
					labelEl.style.marginBottom = "4px";

					const placeholder = String(field.placeholder ?? "");
					const type = field.type ?? "text";
					let inputEl:
						| HTMLInputElement
						| HTMLTextAreaElement
						| HTMLSelectElement;

					if (type === "textarea") {
						inputEl = wrap.createEl("textarea", {
							attr: {
								rows: "4",
								style: "width: 100%;",
								placeholder,
							},
						});
						inputEl.value = String(field.defaultValue ?? "");
						if (!firstFocusableName)
							firstFocusableName = field.name;
					} else if (type === "dropdown") {
						if (
							!Array.isArray(field.options) ||
							field.options.length === 0
						) {
							const fallback = wrap.createEl("input", {
								attr: {
									type: "text",
									style: "width: 100%;",
									placeholder: placeholder || "(enter value)",
									value: String(field.defaultValue ?? ""),
								},
							});
							inputEl = fallback;
							if (!firstFocusableName)
								firstFocusableName = field.name;
						} else {
							const select = wrap.createEl("select", {
								attr: {
									style: "width: 100%;",
								},
							});
							if (placeholder) {
								const opt = select.createEl("option", {
									text: placeholder,
									value: "",
								});
								opt.disabled = true;
								if (
									field.defaultValue == null ||
									String(field.defaultValue) === ""
								) {
									opt.selected = true;
								}
								opt.setAttribute("hidden", "true");
							}

							for (const optDef of field.options) {
								const opt = select.createEl("option", {
									text: String(optDef.label ?? optDef.value),
									value: String(optDef.value),
								});
								if (
									field.defaultValue != null &&
									String(field.defaultValue) ===
										String(optDef.value)
								) {
									opt.selected = true;
								}
							}
							inputEl = select;
							if (!firstFocusableName)
								firstFocusableName = field.name;
						}
					} else if (type === "blockSelect") {
						// Use the portal-based attach function to avoid clipping
						inputEl = attachBlockSelectInput(app, wrap, field);
						if (!firstFocusableName)
							firstFocusableName = field.name;
					} else {
						inputEl = wrap.createEl("input", {
							attr: {
								type: "text",
								style: "width: 100%;",
								placeholder,
								value: String(field.defaultValue ?? ""),
							},
						});
						if (!firstFocusableName)
							firstFocusableName = field.name;
					}

					this.inputs[field.name] = inputEl;

					if (field.description) {
						const desc = wrap.createEl("div", {
							text: String(field.description),
						});
						desc.style.fontSize = "12px";
						desc.style.color = "var(--text-muted)";
						desc.style.marginTop = "4px";
					}
				}

				if (firstFocusableName && this.inputs[firstFocusableName]) {
					const el = this.inputs[firstFocusableName] as
						| HTMLInputElement
						| HTMLTextAreaElement
						| HTMLSelectElement;
					setTimeout(() => {
						try {
							el.focus();
							if (
								(el as HTMLInputElement).setSelectionRange &&
								(el as HTMLInputElement).type !== "checkbox" &&
								el.tagName.toLowerCase() !== "select"
							) {
								const v = (el as HTMLInputElement).value ?? "";
								(el as HTMLInputElement).setSelectionRange(
									v.length,
									v.length
								);
							}
						} catch {
							// ignore
						}
					}, 0);
				}

				const btnRow = contentEl.createEl("div", {
					attr: { style: "display:flex; gap:8px; margin-top: 12px;" },
				});
				const okBtn = btnRow.createEl("button", {
					text: isEdit ? "Update" : "Insert",
				});
				const cancelBtn = btnRow.createEl("button", { text: "Cancel" });

				okBtn.addEventListener("click", () => {
					if (this.resolved) return;
					const values: Record<string, unknown> = {};
					let valid = true;

					for (const field of (schema.fields ??
						[]) as ParamsSchemaField[]) {
						const el = this.inputs[field.name];
						let raw = "";

						if (!el) {
							raw = "";
						} else if (el instanceof HTMLSelectElement) {
							raw = String(el.value ?? "");
						} else if (el instanceof HTMLInputElement) {
							raw = String(el.value ?? "");
						} else if (el instanceof HTMLTextAreaElement) {
							raw = String(el.value ?? "");
						} else {
							raw = String((el as HTMLElement).textContent ?? "");
						}

						if (field.required && raw.trim().length === 0) {
							new Notice(
								`"${field.label ?? field.name}" is required`
							);
							valid = false;
							break;
						}

						values[field.name] = raw;
					}

					if (!valid) return;
					this.resolved = true;
					this.close();
					resolve(values);
				});

				cancelBtn.addEventListener("click", () => {
					if (this.resolved) return;
					this.resolved = true;
					this.close();
					resolve(undefined);
				});
			}

			onClose(): void {
				this.contentEl.empty();
			}
		})(app);

		modal.open();
	});
}

./src/composition/container.ts
import type { Plugin, App } from "obsidian";
import type { AgileObsidianSettings } from "@settings";
import type { SettingsService } from "@settings";
import { createSettingsService } from "@settings";
import type { OrgStructurePort } from "@features/org-structure";
import type { TeamInfo } from "@features/org-structure";
import type { OrgStructureResult } from "@features/org-structure";
import type { TaskIndexService } from "@features/task-index";

/**
 * The composition container provides access to the Obsidian plugin runtime,
 * live settings, and feature ports/services that are wired at boot.
 *
 * Important: `settings` is a "live-view" getter so consumers never read stale
 * snapshots if the settings object is replaced by the settings module.
 */
export interface Container {
	plugin: Plugin;
	app: App;

	/**
	 * Live view of plugin settings. Getter-backed to always reflect current settings.
	 */
	settings: AgileObsidianSettings;

	settingsService: SettingsService;
	manifestId: string;

	// Wiring ports (optional) to keep features decoupled from composition
	taskIndexService?: TaskIndexService;

	orgStructureService?: {
		getOrgStructure: () => OrgStructureResult;
		getTeamMembersForPath: (path: string) => {
			members: TeamInfo["members"];
			buckets: any;
			team: TeamInfo | null;
		};
	};
	orgStructurePorts?: { orgStructure: OrgStructurePort };
}

/**
 * Create the composition container for the plugin.
 */
export function createContainer(
	plugin: Plugin & { settings: AgileObsidianSettings }
): Container {
	const app = (plugin as any).app as App;

	const settingsService = createSettingsService(
		() => (plugin as any).settings
	);

	const container: any = {
		plugin,
		app,
		settingsService,
		manifestId: sanitizeScopeId((plugin as any).manifest?.id ?? ""),
	};

	Object.defineProperty(container, "settings", {
		get() {
			return (plugin as any).settings as AgileObsidianSettings;
		},
		set(_v: AgileObsidianSettings) {
			// No-op to prevent external mutation; settings are plugin-owned.
		},
		enumerable: true,
		configurable: false,
	});

	return container as Container;
}

/** Defensive sanitize for any DOM/CSS scoping usage (e.g., style injection). */
function sanitizeScopeId(id: string): string {
	return (id ?? "").replace(/[^a-zA-Z0-9._:-]+/g, "-");
}

./src/composition/index.ts
/**
 * Composition module barrel.
 * Exposes the public API used by the plugin entry point.
 */
export * from "./container";
export * from "./register-commands";
export * from "./register-events";
export * from "./register-settings";
export * from "./register-styles";

./src/composition/lifecycle.ts
/**
 * Small lifecycle helper for manual disposables that are NOT covered by plugin.registerEvent.
 * Use this for DOM listeners, timers, or any function that returns a cleanup.
 */
export type Disposer = () => void | Promise<void>;

export class DisposableStack {
	private readonly stack: Disposer[] = [];

	add<T extends Disposer>(d: T): T {
		this.stack.push(d);
		return d;
	}

	/** Adds a timeout and returns a cancel function. */
	setTimeout(fn: () => void, ms: number): Disposer {
		const id = window.setTimeout(fn, ms);
		return this.add(() => window.clearTimeout(id));
	}

	/** Adds a rAF and returns a cancel function. */
	requestAnimationFrame(fn: FrameRequestCallback): Disposer {
		const id = window.requestAnimationFrame(fn);
		return this.add(() => window.cancelAnimationFrame(id));
	}

	/** Runs all disposers LIFO. Swallows errors to avoid partial leaks. */
	disposeAll(): void {
		while (this.stack.length) {
			const d = this.stack.pop()!;
			try {
				const ret = d();
				if (ret && typeof (ret as any).then === "function") {
					// Fire and forget; composition unloading doesn't need to await
					(ret as Promise<void>).catch(() => void 0);
				}
			} catch {
				// swallow on dispose path
			}
		}
	}
}

./src/composition/logging.ts
/** Minimal namespaced logger to keep logs consistent and searchable. */
export function createLogger(ns: string) {
	const prefix = `[${ns}]`;
	return {
		debug: (...a: any[]) => console.debug(prefix, ...a),
		info: (...a: any[]) => console.info(prefix, ...a),
		warn: (...a: any[]) => console.warn(prefix, ...a),
		error: (...a: any[]) => console.error(prefix, ...a),
	};
}

./src/composition/register-commands.ts
import type { Container } from "./container";
import { registerAgileDashboardView } from "@features/agile-dashboard-view";
import { registerTemplatingDynamicCommands } from "@features/templating-engine";
import { registerTaskAssignmentDynamicCommands } from "@features/task-assignment";

/**
 * Registers all user-facing commands.
 * Safe to call early; will opportunistically inject TaskIndex/OrgStructure ports if available.
 */
export async function registerAllCommands(container: Container) {
	// Feature: Agile dashboard view
	await registerAgileDashboardView(container);

	// Feature: Dynamic template commands based on cursor context
	await registerTemplatingDynamicCommands(
		container.app,
		container.plugin as any,
		container.manifestId,
		container.taskIndexService
			? {
					taskIndex: {
						getItemAtCursor: (cursor) =>
							container.taskIndexService!.getItemAtCursor(
								cursor
							) as any,
						getTaskByBlockRef: (ref) =>
							container.taskIndexService!.getTaskByBlockRef(
								ref
							) as any,
					},
			  }
			: undefined
	);

	// Feature: Task assignment commands (members + special "Everyone")
	if (container.orgStructurePorts?.orgStructure) {
		await registerTaskAssignmentDynamicCommands(
			container.app,
			container.plugin as any,
			container.manifestId,
			{ orgStructure: container.orgStructurePorts.orgStructure }
		);
	}
}

./src/composition/register-events.ts
import type { Container } from "./container";
import { MarkdownView, Notice as ObsidianNotice } from "obsidian";
import { wireTaskIndex } from "./wire/task-index";
import { wireCanonicalFormatterForView } from "./wire/canonical-formatter";
import { wireTemplatingForView } from "./wire/templating";
import { wireOrgStructure } from "./wire/org-structure";
import { wireTaskFlows } from "./wire/task-flows";
import { normalizeTaskLine } from "@features/task-canonical-formatter";

/**
 * Registers runtime event wiring and feature bootstrap.
 * This function is intentionally orchestration-only and delegates details to wire/* modules.
 */
export async function registerEvents(container: Container) {
	const { app, plugin } = container;

	// 1) TaskIndex wiring and ports
	const { taskIndexPorts } = await wireTaskIndex(container);

	// 2) Per-view wiring (templating + canonical formatting + assignment DOM handlers)
	let currentView: MarkdownView | null = null;
	let currentCanonicalDisposer: (() => void) | null = null;

	const unwireCurrentView = () => {
		if (currentCanonicalDisposer) {
			try {
				currentCanonicalDisposer();
			} catch {}
			currentCanonicalDisposer = null;
		}
		currentView = null;
	};

	const wireForActiveView = () => {
		const active = app.workspace.getActiveViewOfType(MarkdownView) ?? null;
		if (currentView === active) return;
		if (currentView) unwireCurrentView();
		currentView = active;
		if (!currentView) return;

		// Templating DOM handlers + UX shortcuts
		wireTemplatingForView(app, currentView, plugin, taskIndexPorts);

		// Canonical formatter
		currentCanonicalDisposer = wireCanonicalFormatterForView(
			currentView,
			container
		);

		// Task assignment DOM handlers are wired by feature module internally if available (org-structure), via wireOrgStructure
		// to avoid duplication here.
	};

	// Initial wire and listeners to rewire on leaf/file changes
	wireForActiveView();

	plugin.registerEvent(
		app.workspace.on("active-leaf-change", (_leaf) => wireForActiveView())
	);
	plugin.registerEvent(
		app.workspace.on("file-open", (_file) => wireForActiveView())
	);

	// 3) Vault-wide "Format All Files" wiring (triggered from Settings UI)
	plugin.registerEvent(
		// @ts-ignore - custom workspace events supported
		app.workspace.on("agile-canonical-format-all", async () => {
			try {
				const mdFiles = app.vault.getMarkdownFiles();
				let changedFiles = 0;
				let changedLines = 0;

				for (const f of mdFiles) {
					const content = await app.vault.read(f);

					// Preserve EOL style and terminal newline
					const useCRLF = content.includes("\r\n");
					const eol = useCRLF ? "\r\n" : "\n";
					const hasTerminalEOL = content.endsWith(eol);

					const lines = content.split(/\r?\n/);
					let fileChanged = false;
					const out: string[] = new Array(lines.length);

					for (let i = 0; i < lines.length; i++) {
						const oldLine = lines[i] ?? "";
						const indentMatch = oldLine.match(/^\s*/);
						const indent = indentMatch ? indentMatch[0] : "";
						const sansIndent = oldLine.slice(indent.length);
						const normalizedSansIndent =
							normalizeTaskLine(sansIndent);
						const newLine = indent + normalizedSansIndent;
						out[i] = newLine;
						if (newLine !== oldLine) {
							fileChanged = true;
							changedLines++;
						}
					}

					if (fileChanged) {
						let next = out.join(eol);
						if (hasTerminalEOL && !next.endsWith(eol)) {
							next += eol;
						} else if (!hasTerminalEOL && next.endsWith(eol)) {
							next = next.slice(0, -eol.length);
						}
						await app.vault.modify(f, next);
						changedFiles++;
					}
				}

				new ObsidianNotice(
					`Canonical formatting complete: ${changedFiles} file(s), ${changedLines} line(s) updated.`
				);
			} catch (e) {
				new ObsidianNotice(
					`Canonical formatting failed: ${
						e instanceof Error ? e.message : String(e)
					}`
				);
			}
		})
	);

	// 4) Org Structure wiring (debounced vault watchers + assignment commands + ports)
	const { orgStructurePort } = await wireOrgStructure(container);

	// 5) Task flows (cascades, status sequence, close manager, metadata cleanup)
	wireTaskFlows(container);

	// 6) When org-structure is present, wire task assignment DOM handlers for the active view
	//    via rewire (so it tracks view changes). The feature module owns its own cleanup.
	const wireAssignmentHandlersForActive = () => {
		const orgPorts = { orgStructure: orgStructurePort };
		const view = app.workspace.getActiveViewOfType(MarkdownView);
		if (!view) return;
		try {
			const {
				wireTaskAssignmentDomHandlers,
			} = require("@features/task-assignment");
			wireTaskAssignmentDomHandlers(app, view, plugin, orgPorts);
		} catch {
			// Feature may not expose dom wiring in this runtime, ignore.
		}
	};
	wireAssignmentHandlersForActive();
	plugin.registerEvent(
		app.workspace.on("active-leaf-change", (_leaf) =>
			wireAssignmentHandlersForActive()
		)
	);
	plugin.registerEvent(
		app.workspace.on("file-open", (_file) =>
			wireAssignmentHandlersForActive()
		)
	);
}

./src/composition/register-settings.ts
import { createDefaultSettings, createSettingsTab } from "@settings";
import type { AgileObsidianSettings } from "@settings";
import type { Plugin } from "obsidian";
import type { Container } from "./container";
import { registerOrgStructureSettings } from "@features/org-structure";
import { registerCustomCheckboxesSettings } from "@styles/custom-checkboxes";
import { applyCheckboxStylesSetting } from "./register-styles";

/**
 * Initializes settings by loading persisted data (if available) and applying defaults.
 */
export async function initSettings(
	plugin: Plugin & {
		settings?: AgileObsidianSettings;
		loadData?: () => Promise<Partial<AgileObsidianSettings> | null>;
		saveData?: (data: AgileObsidianSettings) => Promise<void>;
		saveSettings?: () => Promise<void>;
	}
): Promise<AgileObsidianSettings> {
	const stored = await plugin.loadData?.();
	const settings: AgileObsidianSettings = createDefaultSettings(
		stored ?? null
	);
	plugin.settings = settings;
	return settings;
}

/**
 * Registers the plugin settings tab and hooks feature-specific settings sub-systems.
 */
export async function registerSettings(container: Container) {
	const { app, plugin, settings } = container;
	const p = plugin as Plugin & {
		saveSettings?: () => Promise<void>;
		saveData?: (data: AgileObsidianSettings) => Promise<void>;
		addSettingTab: (tab: any) => void;
	};

	const saveSettingsLocal = async (): Promise<void> => {
		if (typeof p.saveSettings === "function") await p.saveSettings();
		else if (typeof p.saveData === "function") await p.saveData(settings);

		try {
			// @ts-ignore - Obsidian Workspace supports custom events via trigger
			app.workspace.trigger("agile-settings-changed");
		} catch (e) {
			console.warn(
				"[settings] Failed to trigger agile-settings-changed",
				e
			);
		}
	};

	const orgActions = registerOrgStructureSettings({
		app,
		plugin,
		settings,
		saveSettings: saveSettingsLocal,
	});

	const checkbox = registerCustomCheckboxesSettings({
		app,
		plugin,
		settings,
		applyCheckboxStyles: async () =>
			await applyCheckboxStylesSetting(container),
	});

	p.addSettingTab(
		createSettingsTab({
			app,
			plugin: p,
			settings,
			orgActions,
			saveSettings: saveSettingsLocal,
			applyCheckboxStyles: async () =>
				await checkbox.applyCheckboxStyles(),
		}) as any
	);
}

./src/composition/register-styles.ts
import {
	injectCheckboxStyles,
	removeCheckboxStyles,
} from "@styles/custom-checkboxes";
import type { Container } from "./container";

/** Applies/removes checkbox styles based on settings. */
export function applyCheckboxStylesSetting(container: Container) {
	// Defensive sanitize for scope (already sanitized manifestId in container).
	const scopeId = container.manifestId;
	if ((container.settings as any)?.useBundledCheckboxes) {
		injectCheckboxStyles(scopeId);
	} else {
		removeCheckboxStyles(scopeId);
	}
}

/** Registers style application on load and ensures removal on unload. */
export function registerStyles(container: Container) {
	applyCheckboxStylesSetting(container);
	container.plugin.register(() => removeCheckboxStyles(container.manifestId));
}

./src/composition/ui/progress-notice.ts
import type { Notice } from "obsidian";
import { MarkdownView, Notice as ObsidianNotice } from "obsidian";

/**
 * ProgressNotice
 * Per-view strong singleton to show progress for long-running operations.
 * Prevents duplicate instances per MarkdownView and cleans up on end().
 */
export class ProgressNotice {
	private static activeForView = new WeakMap<MarkdownView, ProgressNotice>();
	static getOrCreateForView(view: MarkdownView): ProgressNotice {
		const existing = ProgressNotice.activeForView.get(view);
		if (existing) return existing;
		const created = new ProgressNotice(view);
		ProgressNotice.activeForView.set(view, created);
		return created;
	}

	private constructor(view: MarkdownView) {
		this.view = view;
	}

	private view: MarkdownView;
	private notice: Notice | null = null;
	private wrapper: HTMLDivElement | null = null;
	private bar: HTMLDivElement | null = null;
	private label: HTMLDivElement | null = null;
	private started = false;
	private ended = false;
	private rafId: number | null = null;
	private pendingPct: number = 0;
	private pendingText: string = "";

	private ensureElements(title: string) {
		if (this.notice && this.wrapper && this.bar && this.label) return;
		this.notice = new ObsidianNotice("", 0);
		const wrapper = document.createElement("div");
		wrapper.style.minWidth = "260px";
		wrapper.style.maxWidth = "360px";
		wrapper.style.display = "flex";
		wrapper.style.flexDirection = "column";
		wrapper.style.gap = "8px";
		const titleEl = document.createElement("div");
		titleEl.textContent = title;
		titleEl.style.fontWeight = "600";
		titleEl.style.fontSize = "12px";
		wrapper.appendChild(titleEl);
		const barOuter = document.createElement("div");
		barOuter.style.height = "6px";
		barOuter.style.background = "var(--background-modifier-border)";
		barOuter.style.borderRadius = "3px";
		barOuter.style.overflow = "hidden";
		const barInner = document.createElement("div");
		barInner.style.height = "100%";
		barInner.style.width = "0%";
		barInner.style.background = "var(--interactive-accent)";
		barInner.style.transition = "width 140ms linear";
		barOuter.appendChild(barInner);
		const label = document.createElement("div");
		label.style.fontSize = "11px";
		label.style.opacity = "0.8";
		wrapper.appendChild(barOuter);
		wrapper.appendChild(label);
		(this.notice as any).noticeEl?.empty?.();
		(this.notice as any).noticeEl?.appendChild(wrapper);
		this.wrapper = wrapper;
		this.bar = barInner;
		this.label = label;
	}

	private schedulePaint() {
		if (this.rafId != null) return;
		this.rafId = requestAnimationFrame(() => {
			this.rafId = null;
			if (this.bar) this.bar.style.width = `${this.pendingPct}%`;
			if (this.label) this.label.textContent = this.pendingText;
		});
	}

	start(title: string, total: number) {
		if (this.ended || this.started) return;
		this.started = true;
		this.ensureElements(title);
		this.pendingPct = 0;
		this.pendingText = `0 / ${Math.max(0, total)}`;
		this.schedulePaint();
	}

	update(current: number, total: number, message?: string) {
		if (!this.started || this.ended) return;
		const clampedTotal = Math.max(1, total);
		const clampedCur = Math.max(0, Math.min(current, clampedTotal));
		const pct = Math.floor((clampedCur / clampedTotal) * 100);
		this.pendingPct = pct;
		this.pendingText =
			message ?? `${clampedCur} / ${clampedTotal} (${pct}%)`;
		this.schedulePaint();
	}

	end() {
		if (this.ended) return;
		this.ended = true;
		if (this.notice) this.notice.hide();
		this.cleanup();
	}

	private cleanup() {
		if (this.rafId != null) {
			cancelAnimationFrame(this.rafId);
			this.rafId = null;
		}
		this.notice = null;
		this.wrapper = null;
		this.bar = null;
		this.label = null;
		this.started = false;
		ProgressNotice.activeForView.delete(this.view);
	}
}

./src/composition/wire/canonical-formatter.ts
import { MarkdownView } from "obsidian";
import type { Container } from "../container";
import { ProgressNotice } from "../ui/progress-notice";
import {
	createCanonicalFormatterService,
	createCanonicalFormatterOrchestrator,
} from "@features/task-canonical-formatter";
import type { CanonicalFormatterPort } from "@features/task-canonical-formatter";

/**
 * Wires canonical formatter for a specific MarkdownView.
 * Returns a disposer that tears down all listeners for this view.
 */
export function wireCanonicalFormatterForView(
	view: MarkdownView,
	container: Container
): () => void {
	const editor = view.editor;
	if (!editor) return () => void 0;

	// Mutation barrier to avoid re-entrancy from our own writes.
	let isMutating = false;

	let lastDocLineCount = editor.lineCount();
	let lastCursorLine = editor.getCursor().line;
	const progress = ProgressNotice.getOrCreateForView(view);
	const { app } = container;

	const getSettingsSnapshot = () => {
		try {
			const svc: any = container.settingsService as any;
			if (svc && typeof svc.getRaw === "function") return svc.getRaw();
			if (svc && typeof svc.get === "function") return svc.get();
		} catch {}
		return container.settings;
	};

	const getFlags = () => {
		const s: any = getSettingsSnapshot();
		return {
			master: !!s.enableTaskCanonicalFormatter,
			onLineCommit: !!s.enableCanonicalOnLineCommit,
			onLeafChange: !!s.enableCanonicalOnLeafChange,
		};
	};

	const port: CanonicalFormatterPort = {
		getCurrentLine: () => {
			const cursor = editor.getCursor();
			const lineNumber = cursor.line;
			const line = editor.getLine(lineNumber);
			if (typeof line !== "string") return null;
			const from = editor.getCursor("from");
			const to = editor.getCursor("to");
			const hasRange = from.line !== to.line || from.ch !== to.ch;
			let selection: { start: number; end: number } | undefined;
			if (
				hasRange &&
				from.line === lineNumber &&
				to.line === lineNumber
			) {
				selection = { start: from.ch, end: to.ch };
			} else if (!hasRange && cursor.line === lineNumber) {
				selection = { start: cursor.ch, end: cursor.ch };
			}
			return { line, lineNumber, selection };
		},
		getLineAt: (lineNumber: number) => {
			if (
				typeof lineNumber !== "number" ||
				lineNumber < 0 ||
				lineNumber >= editor.lineCount()
			) {
				return null;
			}
			const line = editor.getLine(lineNumber);
			return typeof line === "string" ? line : null;
		},
		replaceLineWithSelection: (lineNumber, newLine, newSel) => {
			const oldLine = editor.getLine(lineNumber);
			if (oldLine === newLine) return;
			isMutating = true;
			try {
				editor.replaceRange(
					newLine,
					{ line: lineNumber, ch: 0 },
					{ line: lineNumber, ch: oldLine.length }
				);
				editor.setSelection(
					{ line: lineNumber, ch: newSel.start },
					{ line: lineNumber, ch: newSel.end }
				);
			} finally {
				isMutating = false;
			}
		},
		replaceLine: (lineNumber, newLine) => {
			const oldLine = editor.getLine(lineNumber);
			if (oldLine === newLine) return;
			isMutating = true;
			try {
				editor.replaceRange(
					newLine,
					{ line: lineNumber, ch: 0 },
					{ line: lineNumber, ch: oldLine.length }
				);
			} finally {
				isMutating = false;
			}
		},
		replaceAllLines: (newLines: string[]) => {
			try {
				const current = editor.getValue();
				const eol = current.includes("\r\n") ? "\r\n" : "\n";
				const next = newLines.join(eol);
				if (next === current) return;

				const cur = editor.getCursor();
				isMutating = true;
				try {
					if (typeof (editor as any).setValue === "function") {
						(editor as any).setValue(next);
					} else {
						const lineCount = editor.lineCount();
						const lastLineLen =
							editor.getLine(lineCount - 1)?.length ?? 0;
						editor.replaceRange(
							next,
							{ line: 0, ch: 0 },
							{ line: lineCount - 1, ch: lastLineLen }
						);
					}
					const maxLine = Math.max(0, editor.lineCount() - 1);
					const line = Math.min(cur.line, maxLine);
					const lineLen = editor.getLine(line)?.length ?? 0;
					const ch = Math.max(0, Math.min(cur.ch, lineLen));
					if (typeof (editor as any).setCursor === "function") {
						(editor as any).setCursor({ line, ch });
					}
				} finally {
					isMutating = false;
				}
			} catch {
				// swallow
			}
		},
		getCursorLine: () => editor.getCursor().line,
		getAllLines: () => {
			const lc = editor.lineCount();
			const lines: string[] = [];
			for (let i = 0; i < lc; i++) lines.push(editor.getLine(i));
			return lines;
		},
		onProgressStart: ({ title, total }) => progress.start(title, total),
		onProgressUpdate: ({ current, total, message }) =>
			progress.update(current, total, message),
		onProgressEnd: () => progress.end(),

		onLineCommitted: (cb) => {
			let detachDom: (() => void) | null = null;

			const cmContent: HTMLElement | undefined = (editor as any)?.cm
				?.contentDOM;
			const queriedContent = view.containerEl.querySelector(
				".cm-content"
			) as HTMLElement | null;
			const el: HTMLElement | null =
				(cmContent ?? queriedContent) || null;

			const keyHandler = (ev: KeyboardEvent) => {
				if (isMutating) return;
				if (ev.key === "Enter" && !ev.isComposing) {
					const flags = getFlags();
					if (!flags.master || !flags.onLineCommit) return;
					cb();
				}
			};

			if (el && typeof el.addEventListener === "function") {
				el.addEventListener("keydown", keyHandler, true);
				detachDom = () =>
					el.removeEventListener("keydown", keyHandler, true);
			}

			const off = app.workspace.on("editor-change", (_maybeView) => {
				if (isMutating) return;
				const active = app.workspace.getActiveViewOfType(MarkdownView);
				if (active !== view) return;

				const currentCount = editor.lineCount();
				if (currentCount > lastDocLineCount) {
					const flags = getFlags();
					if (!flags.master || !flags.onLineCommit) {
						lastDocLineCount = currentCount;
						return;
					}
					cb();
				}
				lastDocLineCount = currentCount;
			});

			return () => {
				if (detachDom) {
					try {
						detachDom();
					} catch {}
				}
				app.workspace.offref(off);
			};
		},

		onCursorLineChanged: (cb) => {
			let detachFns: Array<() => void> = [];

			const cmContent: HTMLElement | undefined = (editor as any)?.cm
				?.contentDOM;
			const queriedContent = view.containerEl.querySelector(
				".cm-content"
			) as HTMLElement | null;
			const targetEl: HTMLElement | null =
				(cmContent ?? queriedContent) || null;

			let rafId: number | null = null;
			const scheduleNotify = () => {
				if (rafId != null) return;
				rafId = requestAnimationFrame(() => {
					rafId = null;
					notifyIfChanged();
				});
			};

			const notifyIfChanged = () => {
				if (isMutating) return;
				const active =
					container.app.workspace.getActiveViewOfType(MarkdownView);
				if (active !== view) return;

				const nextLine = editor.getCursor().line;
				if (nextLine !== lastCursorLine) {
					const prevLine = lastCursorLine;
					lastCursorLine = nextLine;
					const flags = getFlags();
					if (!flags.master || !flags.onLineCommit) return;
					try {
						cb({ prevLine, nextLine });
					} catch {}
				}
			};

			const selectionHandler = () => {
				try {
					const sel = document.getSelection();
					if (!sel || !sel.anchorNode) return;

					if (targetEl && targetEl.contains(sel.anchorNode)) {
						scheduleNotify();
					} else if (!targetEl) {
						const active =
							container.app.workspace.getActiveViewOfType(
								MarkdownView
							);
						if (active === view) scheduleNotify();
					}
				} catch {}
			};
			document.addEventListener(
				"selectionchange",
				selectionHandler,
				true
			);
			detachFns.push(() =>
				document.removeEventListener(
					"selectionchange",
					selectionHandler,
					true
				)
			);

			if (targetEl) {
				const pointerUp = () => scheduleNotify();
				const click = () => scheduleNotify();
				targetEl.addEventListener("pointerup", pointerUp, true);
				targetEl.addEventListener("click", click, true);
				detachFns.push(() =>
					targetEl.removeEventListener("pointerup", pointerUp, true)
				);
				detachFns.push(() =>
					targetEl.removeEventListener("click", click, true)
				);
			}

			if (targetEl) {
				const navKeyHandler = (ev: KeyboardEvent) => {
					if (isMutating) return;
					switch (ev.key) {
						case "ArrowUp":
						case "ArrowDown":
						case "PageUp":
						case "PageDown":
						case "Home":
						case "End":
							scheduleNotify();
							break;
					}
				};
				targetEl.addEventListener("keydown", navKeyHandler, true);
				detachFns.push(() =>
					targetEl.removeEventListener("keydown", navKeyHandler, true)
				);
			}

			const offEdit = container.app.workspace.on(
				"editor-change",
				(_maybeView) => {
					const active =
						container.app.workspace.getActiveViewOfType(
							MarkdownView
						);
					if (active !== view) return;
					scheduleNotify();
				}
			);
			detachFns.push(() => container.app.workspace.offref(offEdit));

			return () => {
				for (const off of detachFns) {
					try {
						off();
					} catch {}
				}
				if (rafId != null) {
					try {
						cancelAnimationFrame(rafId);
					} catch {}
					rafId = null;
				}
				detachFns = [];
			};
		},

		onLeafOrFileChanged: (cb) => {
			const off1 = app.workspace.on("active-leaf-change", (_leaf) => {
				if (isMutating) return;
				const active = app.workspace.getActiveViewOfType(MarkdownView);
				if (active === view) {
					const flags = getFlags();
					if (!flags.master || !flags.onLeafChange) return;
					cb();
				}
			});
			const off2 = app.workspace.on("file-open", (_file) => {
				if (isMutating) return;
				const active = app.workspace.getActiveViewOfType(MarkdownView);
				if (active === view) {
					const flags = getFlags();
					if (!flags.master || !flags.onLeafChange) return;
					cb();
				}
			});
			return () => {
				app.workspace.offref(off1);
				app.workspace.offref(off2);
			};
		},
	};

	const svc = createCanonicalFormatterService(port);
	const orchestrator = createCanonicalFormatterOrchestrator(svc, {
		port,
		debounceMs: 300,
		shouldRun: () => getFlags(),
	});
	(view as any).__canonicalProbe = () => {
		orchestrator.triggerOnceNow("manual", "line");
		// Optional: could log or notify here.
	};

	const flagsAtWire = getFlags();
	if (flagsAtWire.master && flagsAtWire.onLeafChange) {
		setTimeout(() => {
			const stillActive =
				container.app.workspace.getActiveViewOfType(MarkdownView) ===
				view;
			if (!stillActive) return;
			orchestrator.triggerOnceNow("leaf-or-file", "file");
		}, 0);
	}

	return () => {
		try {
			orchestrator.dispose();
		} catch {}
		const lingering = (ProgressNotice as any).activeForView?.get?.(view);
		if (lingering) {
			try {
				(lingering as any).end?.();
			} catch {}
		}
	};
}

./src/composition/wire/org-structure.ts
import type { Container } from "../container";
import type { OrgStructurePort } from "@features/org-structure";
import { createOrgStructureService } from "@features/org-structure";
import { registerTaskAssignmentDynamicCommands } from "@features/task-assignment";

/**
 * Boots Org Structure service and wires vault watchers (debounced).
 * Exposes ports on the container and registers assignment commands.
 */
export async function wireOrgStructure(container: Container): Promise<{
	orgStructurePort: OrgStructurePort;
	dispose: () => void;
}> {
	const { app, plugin } = container;
	const orgStructureService = createOrgStructureService({
		app,
		settings: container.settings,
	});
	await orgStructureService.buildAll();

	let rebuildTimer: number | null = null;
	const scheduleRebuild = () => {
		if (rebuildTimer != null) window.clearTimeout(rebuildTimer);
		rebuildTimer = window.setTimeout(() => {
			rebuildTimer = null;
			// fire and forget
			orgStructureService["buildAll"]();
		}, 200);
	};

	plugin.registerEvent(app.vault.on("create", scheduleRebuild));
	plugin.registerEvent(app.vault.on("modify", scheduleRebuild));
	plugin.registerEvent(app.vault.on("delete", scheduleRebuild));
	plugin.registerEvent(app.vault.on("rename", scheduleRebuild));

	const orgStructurePort: OrgStructurePort = {
		getOrgStructure: orgStructureService.getOrgStructure,
		getTeamMembersForFile: orgStructureService.getTeamMembersForPath,
	};

	(container as any).orgStructureService = orgStructureService;
	(container as any).orgStructurePorts = { orgStructure: orgStructurePort };

	try {
		await registerTaskAssignmentDynamicCommands(
			app,
			plugin,
			plugin.manifest.id,
			{
				orgStructure: orgStructurePort,
			}
		);
	} catch (e) {
		console.error("[boot] assignment commands failed", e);
	}

	return {
		orgStructurePort,
		dispose: () => {
			if (rebuildTimer != null) {
				window.clearTimeout(rebuildTimer);
				rebuildTimer = null;
			}
		},
	};
}

./src/composition/wire/task-flows.ts
import type { Container } from "../container";
import { wireTaskAssignmentCascade } from "@features/task-assignment-cascade";
import { wireTaskClosedCascade } from "@features/task-close-cascade";
import { registerTaskMetadataCleanup } from "@features/task-metadata-cleanup";
import { wireTaskCloseManager } from "@features/task-close-manager";
import { wireTaskStatusSequence } from "@features/task-status-sequencer";

/**
 * Wires cross-cutting task flows and cleanup behaviors.
 */
export function wireTaskFlows(container: Container): void {
	const { app, plugin, taskIndexService } = container;

	try {
		if (taskIndexService) {
			wireTaskAssignmentCascade(app, plugin, {
				taskIndex: taskIndexService,
			});
		}
	} catch (e) {
		console.error("[boot] assignment cascade wiring failed", e);
	}

	try {
		// 1) Status sequence first to override defaults
		wireTaskStatusSequence(app, plugin);
		// 2) Close manager reacts to transitions
		wireTaskCloseManager(app, plugin);
		// Custom-event adapter
		wireTaskClosedCascade(app, plugin);
	} catch (e) {
		console.error("[boot] closed cascade wiring failed", e);
	}

	try {
		registerTaskMetadataCleanup(container);
	} catch (e) {
		console.error("[boot] task-metadata-cleanup wiring failed", e);
	}
}

./src/composition/wire/task-index.ts
import type { TAbstractFile, TFile } from "obsidian";
import type { Container } from "../container";
import { createObsidianAppAdapter } from "@platform/obsidian";
import {
	createTaskIndexService,
	createTaskIndexOrchestrator,
} from "@features/task-index";
import type { TaskIndexPort } from "@features/templating-engine";

/**
 * Bootstraps TaskIndex and wires vault events for incremental updates.
 * Returns templating ports and a dispose function for non-Plugin-managed disposables (none here).
 */
export async function wireTaskIndex(container: Container): Promise<{
	taskIndexPorts: { taskIndex: TaskIndexPort };
}> {
	const { app, plugin } = container;
	const appAdapter = createObsidianAppAdapter(app);

	const taskIndexService = createTaskIndexService({ appAdapter });
	const taskIndexOrchestrator = createTaskIndexOrchestrator(taskIndexService);

	container.taskIndexService = taskIndexService;

	await taskIndexOrchestrator.buildAll();

	const asFile = (f: TAbstractFile | null): f is TFile =>
		!!f && (f as TFile).extension !== undefined;

	plugin.registerEvent(
		app.vault.on("create", async (file) => {
			if (asFile(file) && file.extension === "md") {
				await taskIndexOrchestrator.onFileCreated(file);
			}
		})
	);
	plugin.registerEvent(
		app.vault.on("modify", async (file) => {
			if (asFile(file) && file.extension === "md") {
				await taskIndexOrchestrator.onFileModified(file);
			}
		})
	);
	plugin.registerEvent(
		app.vault.on("delete", async (abstractFile) => {
			if (asFile(abstractFile)) {
				taskIndexOrchestrator.onFileDeleted(abstractFile.path);
			}
		})
	);
	plugin.registerEvent(
		app.vault.on("rename", async (file, oldPath) => {
			if (asFile(file)) {
				await taskIndexOrchestrator.onFileRenamed(oldPath, file.path);
			}
		})
	);

	const taskIndexPorts: { taskIndex: TaskIndexPort } = {
		taskIndex: {
			getItemAtCursor: (cursor) =>
				taskIndexService.getItemAtCursor(cursor),
			getTaskByBlockRef: (ref) =>
				taskIndexService.getTaskByBlockRef(ref) as any,
		},
	};

	return { taskIndexPorts };
}

./src/composition/wire/templating.ts
import type { App, MarkdownView, Plugin } from "obsidian";
import { wireTemplatingDomHandlers } from "@features/templating-engine";
import { wireTemplatingUxShortcutsDomHandlers } from "@features/templating-ux-shortcuts";
import type { TaskIndexPort } from "@features/templating-engine";

/**
 * Wires templating DOM handlers and UX shortcuts for the active view.
 * Note: underlying features manage their own cleanup via plugin.register; this function
 * is intentionally thin to avoid duplicating internal lifecycles.
 */
export function wireTemplatingForView(
	app: App,
	view: MarkdownView,
	plugin: Plugin,
	ports: { taskIndex: TaskIndexPort }
): void {
	try {
		wireTemplatingDomHandlers(app, view, plugin, {
			taskIndex: ports.taskIndex,
		});
	} catch {}
	try {
		wireTemplatingUxShortcutsDomHandlers(app, view, plugin);
	} catch {}
}

